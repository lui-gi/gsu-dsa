<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heap Data Structure Visualization</title>
    <style>
        /* GSU Color Palette & Basic Reset */
        :root {
            --gsu-blue: #0039A6;
            --gsu-dark: #1f2a36; /* Darker variant for contrast */
            --gsu-gray: #777777;
            --light-bg: #f4f4f4;
            --highlight: #CC0000; /* Red for active action */
            --success: #28a745;
            --node-radius: 22;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: var(--light-bg);
            color: #333;
        }

        header {
            background-color: var(--gsu-blue);
            color: white;
            padding: 1rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        h1 { margin: 0; font-size: 1.6rem; letter-spacing: 0.5px; }
        p { margin: 5px 0 0; opacity: 0.9; font-size: 0.9rem; }

        /* Controls Section */
        .controls {
            background: white;
            padding: 1rem;
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            border-bottom: 2px solid #ddd;
            z-index: 10;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #f8f9fa;
            padding: 5px 10px;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }

        input[type="number"], input[type="text"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1rem;
            width: 80px;
        }

        input[type="text"] { width: 180px; }

        button {
            background-color: var(--gsu-blue);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }

        button:hover { background-color: #00256e; }
        button:disabled { background-color: var(--gsu-gray); cursor: not-allowed; }
        
        button.secondary { background-color: var(--gsu-gray); }
        button.danger { background-color: var(--highlight); }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 140px;
            height: 34px;
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            font-size: 0.8rem;
            font-weight: bold;
            color: white;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--gsu-blue); }
        input:checked + .slider:before { transform: translateX(106px); }
        .label-min { margin-right: auto; color: #555; z-index: 1; }
        .label-max { margin-left: auto; color: white; z-index: 1; display: none;}
        input:checked + .slider .label-min { display: none; }
        input:checked + .slider .label-max { display: block; }

        /* Main Visualization Area */
        #main-container {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            padding: 10px;
            gap: 10px;
            overflow: hidden;
        }

        .status-bar {
            text-align: center;
            font-style: italic;
            color: var(--gsu-gray);
            height: 20px;
        }

        /* Tree View */
        #canvas-container {
            flex-grow: 2;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* Array View */
        #array-container {
            flex-grow: 0;
            height: 120px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            padding: 15px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .array-label {
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--gsu-blue);
            font-size: 0.9rem;
        }

        .array-box {
            display: flex;
            gap: 5px;
            overflow-x: auto;
            padding-bottom: 10px;
            align-items: center;
            height: 60px;
        }

        .array-cell {
            width: 40px;
            height: 40px;
            border: 2px solid var(--gsu-blue);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: var(--gsu-blue);
            border-radius: 4px;
            position: relative;
            background: white;
            transition: all 0.3s;
            flex-shrink: 0;
        }

        .array-cell span.idx {
            position: absolute;
            bottom: -20px;
            font-size: 0.7rem;
            color: #999;
            font-weight: normal;
        }

        .array-cell.highlight {
            background-color: var(--highlight);
            color: white;
            border-color: var(--highlight);
            transform: scale(1.1);
        }
        
        .array-cell.compare {
            background-color: #ffc107; /* Warning yellow */
            border-color: #ffc107;
        }

        .legend {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.9);
            padding: 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .legend-item { display: flex; align-items: center; gap: 6px; margin-bottom: 4px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; }

    </style>
</head>
<body>

<header>
    <h1>Heap Visualization</h1>
    <p>Compare Tree View vs. Array Implementation</p>
</header>

<div class="controls">
    
    <!-- Mode Toggle -->
    <div class="control-group">
        <label class="toggle-switch">
            <input type="checkbox" id="modeToggle">
            <span class="slider">
                <span class="label-min">Min Heap</span>
                <span class="label-max">Max Heap</span>
            </span>
        </label>
    </div>

    <!-- Basic Operations -->
    <div class="control-group">
        <input type="number" id="numInput" placeholder="#" onkeypress="handleEnter(event)">
        <button onclick="handleAdd()">Insert</button>
        <button class="secondary" onclick="handleRemove()">Remove Root</button>
    </div>

    <!-- Heapify -->
    <div class="control-group">
        <input type="text" id="heapifyInput" placeholder="10, 5, 20, 3...">
        <button onclick="handleHeapify()">Heapify List</button>
    </div>

    <div class="control-group">
        <button class="danger" onclick="handleClear()">Clear</button>
    </div>

    <div class="control-group">
        <label style="font-size: 0.8rem;">Speed:</label>
        <input type="range" id="speedRange" min="1" max="10" value="6">
    </div>
</div>

<div class="status-bar" id="status">Ready.</div>

<div id="main-container">
    <div id="canvas-container">
        <canvas id="treeCanvas"></canvas>
        <div class="legend">
            <div class="legend-item"><span class="dot" style="background: #0039A6"></span> Node</div>
            <div class="legend-item"><span class="dot" style="background: #CC0000"></span> Active/Swap</div>
            <div class="legend-item"><span class="dot" style="background: #ffc107"></span> Compare</div>
        </div>
    </div>
    <div id="array-container">
        <div class="array-label">Array Representation (Index 0 to N-1)</div>
        <div class="array-box" id="arrayVisual">
            <!-- Array cells generated by JS -->
        </div>
    </div>
</div>

<script>
    // --- Configuration & State ---
    let heap = [];
    let isMaxHeap = false; // Default to Min Heap (matches Python heapq)
    const animationQueue = [];
    let isAnimating = false;
    
    // Canvas setup
    const canvas = document.getElementById('treeCanvas');
    const ctx = canvas.getContext('2d');
    
    // Constants
    const NODE_RADIUS = 22;
    const LEVEL_HEIGHT = 70;
    
    // Resize observer for responsive canvas
    new ResizeObserver(() => {
        canvas.width = canvas.parentElement.clientWidth;
        canvas.height = canvas.parentElement.clientHeight;
        // Redraw static state if not animating
        if (!isAnimating) drawTree(null);
    }).observe(document.getElementById('canvas-container'));

    // --- Core Heap Logic (with Animation Steps) ---

    // Helper: Compare based on mode
    const compare = (a, b) => {
        return isMaxHeap ? a > b : a < b;
    };

    const getParent = (i) => Math.floor((i - 1) / 2);
    const getLeft = (i) => 2 * i + 1;
    const getRight = (i) => 2 * i + 2;

    async function insert(val) {
        val = parseInt(val);
        if (isNaN(val)) return;

        // Visual: Add to end
        heap.push(val);
        let index = heap.length - 1;
        
        queueStep('insert-start', index, `Inserted ${val} at index ${index}`);

        // Bubble Up
        while (index > 0) {
            let parentIdx = getParent(index);
            
            queueStep('compare', [index, parentIdx], `Comparing ${heap[index]} with parent ${heap[parentIdx]}`);

            if (compare(heap[index], heap[parentIdx])) {
                // Swap logic
                queueStep('swap', [index, parentIdx], `Swapping because ${heap[index]} ${isMaxHeap ? '>' : '<'} ${heap[parentIdx]}`);
                [heap[index], heap[parentIdx]] = [heap[parentIdx], heap[index]];
                index = parentIdx;
            } else {
                queueStep('success', index, `Heap property satisfied.`);
                break;
            }
        }
        playAnimations();
    }

    async function removeRoot() {
        if (heap.length === 0) return;

        queueStep('highlight', 0, "Selecting Root for removal");

        if (heap.length === 1) {
            heap.pop();
            queueStep('delete', 0, "Removed last element");
            playAnimations();
            return;
        }

        // Swap root with last
        let lastIdx = heap.length - 1;
        queueStep('swap', [0, lastIdx], "Swapping Root with Last Element");
        [heap[0], heap[lastIdx]] = [heap[lastIdx], heap[0]];
        
        // Remove last
        heap.pop();
        queueStep('delete', lastIdx, "Removed old root");

        // Bubble Down
        if (heap.length > 0) {
            await bubbleDown(0);
        }
        playAnimations();
    }

    function bubbleDown(index) {
        let size = heap.length;
        
        while (true) {
            let left = getLeft(index);
            let right = getRight(index);
            let extreme = index; // 'extreme' is smallest in MinHeap, largest in MaxHeap

            queueStep('highlight', index, `Bubbling down index ${index}`);

            // Compare with Left
            if (left < size) {
                queueStep('compare', [extreme, left], `Checking left child ${heap[left]}`);
                if (compare(heap[left], heap[extreme])) {
                    extreme = left;
                }
            }

            // Compare with Right
            if (right < size) {
                queueStep('compare', [extreme, right], `Checking right child ${heap[right]}`);
                if (compare(heap[right], heap[extreme])) {
                    extreme = right;
                }
            }

            if (extreme !== index) {
                queueStep('swap', [index, extreme], "Swapping with child to restore heap property");
                [heap[index], heap[extreme]] = [heap[extreme], heap[index]];
                index = extreme; // Continue down
            } else {
                queueStep('success', index, "Position correct.");
                break;
            }
        }
    }

    function buildHeap(list) {
        heap = list;
        queueStep('reset', null, "Loaded list into array");
        
        // Start from last non-leaf node: floor(n/2) - 1
        let startIdx = Math.floor(heap.length / 2) - 1;

        for (let i = startIdx; i >= 0; i--) {
            queueStep('highlight', i, `Heapify: Processing sub-tree at index ${i}`);
            bubbleDown(i);
        }
        queueStep('success', 0, "Heap construction complete.");
        playAnimations();
    }

    // --- Animation System ---

    function queueStep(type, targets, msg) {
        // Deep copy heap for the visual snapshot
        animationQueue.push({
            type: type,
            targets: Array.isArray(targets) ? targets : [targets],
            heapSnapshot: [...heap],
            msg: msg
        });
    }

    // Helper: Linear Interpolation
    function lerp(start, end, t) {
        return start + (end - start) * t;
    }

    async function playAnimations() {
        if (isAnimating) return;
        isAnimating = true;
        disableControls(true);

        const processStep = async () => {
            if (animationQueue.length === 0) {
                isAnimating = false;
                disableControls(false);
                drawTree(null); // Clean draw
                drawArray(null);
                updateStatus("Ready.");
                return;
            }

            const step = animationQueue.shift();
            const speed = document.getElementById('speedRange').value;
            // Map speed 1-10 to delay/duration (1=slow=1000ms, 10=fast=100ms)
            const duration = 1000 - (speed * 90); 

            drawArray(step);
            updateStatus(step.msg);

            // Special Handling for 'swap': Interpolate movement
            if (step.type === 'swap' && step.targets.length === 2) {
                const idxA = step.targets[0];
                const idxB = step.targets[1];
                
                // Calculate static positions for all nodes based on snapshot size
                const positions = calculatePositions(step.heapSnapshot.length);
                const startA = positions[idxA];
                const startB = positions[idxB];
                
                // We want node at idxA (value X) to move to position of idxB
                // And node at idxB (value Y) to move to position of idxA
                
                return new Promise(resolve => {
                    const startTime = performance.now();
                    
                    const animateSwap = (time) => {
                        let progress = (time - startTime) / duration;
                        if (progress > 1) progress = 1;

                        // Create moving node overrides
                        // The node currently at idxA (in snapshot) moves to pos B
                        // The node currently at idxB (in snapshot) moves to pos A
                        const movingNodes = {
                            [idxA]: {
                                x: lerp(startA.x, startB.x, progress),
                                y: lerp(startA.y, startB.y, progress)
                            },
                            [idxB]: {
                                x: lerp(startB.x, startA.x, progress),
                                y: lerp(startB.y, startA.y, progress)
                            }
                        };

                        drawTree(step, movingNodes);

                        if (progress < 1) {
                            requestAnimationFrame(animateSwap);
                        } else {
                            // Finish swap animation
                            resolve();
                            // Next step immediately
                            processStep();
                        }
                    };
                    requestAnimationFrame(animateSwap);
                });

            } else {
                // Standard Step (Teleport/Static Highlight)
                drawTree(step);
                setTimeout(processStep, duration);
            }
        };

        processStep();
    }

    // --- Visualization Drawing ---

    function calculatePositions(count) {
        const positions = [];
        if (count === 0) return positions;

        const levels = Math.floor(Math.log2(count)) + 1;
        const width = canvas.width;
        
        // Recursive layout calculation
        const getPos = (idx, x, y, spacing) => {
            positions[idx] = { x, y };
            const leftIdx = getLeft(idx);
            const rightIdx = getRight(idx);

            if (leftIdx < count) {
                getPos(leftIdx, x - spacing/2, y + LEVEL_HEIGHT, spacing/2);
            }
            if (rightIdx < count) {
                getPos(rightIdx, x + spacing/2, y + LEVEL_HEIGHT, spacing/2);
            }
        };

        // Root at center, with initial spacing based on canvas width
        getPos(0, width/2, 40, width/1.8);
        return positions;
    }

    function drawArray(step) {
        const container = document.getElementById('arrayVisual');
        container.innerHTML = '';

        // If animation step, use snapshot, else use real heap
        const data = step ? step.heapSnapshot : heap;

        data.forEach((val, i) => {
            const cell = document.createElement('div');
            cell.className = 'array-cell';
            cell.innerHTML = `${val} <span class="idx">${i}</span>`;

            // Styling based on animation state
            if (step) {
                if (step.targets.includes(i)) {
                    if (step.type === 'swap' || step.type === 'insert-start') cell.classList.add('highlight');
                    if (step.type === 'compare') cell.classList.add('compare');
                }
            }
            container.appendChild(cell);
        });
    }

    function drawTree(step, movingNodes = null) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const data = step ? step.heapSnapshot : heap;
        if (data.length === 0) return;

        const positions = calculatePositions(data.length);

        // 1. Draw Edges (Always static based on grid slots)
        positions.forEach((pos, i) => {
            const left = getLeft(i);
            const right = getRight(i);
            
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 2;

            // Draw line to Left child slot
            if (left < data.length && positions[left]) {
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(positions[left].x, positions[left].y);
                ctx.stroke();
            }
            // Draw line to Right child slot
            if (right < data.length && positions[right]) {
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(positions[right].x, positions[right].y);
                ctx.stroke();
            }
        });

        // 2. Draw Nodes
        positions.forEach((staticPos, i) => {
            
            // Determine actual draw position (Static vs Moving)
            let drawPos = staticPos;
            if (movingNodes && movingNodes[i]) {
                drawPos = movingNodes[i];
            }

            // Determine color
            let fill = '#0039A6'; // GSU Blue
            let stroke = '#0039A6';
            
            if (step && step.targets.includes(i)) {
                if (step.type === 'swap' || step.type === 'insert-start' || step.type === 'highlight') {
                    fill = '#CC0000'; // Highlight Red
                    stroke = '#CC0000';
                } else if (step.type === 'compare') {
                    fill = '#ffc107'; // Warning
                    stroke = '#e0a800';
                } else if (step.type === 'success') {
                    fill = '#28a745'; // Success
                    stroke = '#28a745';
                }
            }

            // Circle
            ctx.beginPath();
            ctx.arc(drawPos.x, drawPos.y, NODE_RADIUS, 0, 2 * Math.PI);
            ctx.fillStyle = fill;
            ctx.fill();
            ctx.strokeStyle = stroke;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Text
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(data[i], drawPos.x, drawPos.y);

            // Small index label (Visual sugar)
            if (!movingNodes) {
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.fillText(i, drawPos.x + NODE_RADIUS + 5, drawPos.y - NODE_RADIUS + 5);
            }
        });
    }

    // --- UI Handlers ---

    function handleAdd() {
        const input = document.getElementById('numInput');
        if (!input.value) return;
        insert(input.value);
        input.value = '';
        input.focus();
    }

    function handleRemove() {
        removeRoot();
    }

    function handleHeapify() {
        const raw = document.getElementById('heapifyInput').value;
        const arr = raw.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
        if (arr.length > 0) {
            buildHeap(arr);
        }
    }

    function handleClear() {
        heap = [];
        animationQueue.length = 0;
        drawTree(null);
        drawArray(null);
        updateStatus("Cleared.");
    }

    function handleEnter(e) {
        if (e.key === 'Enter') handleAdd();
    }

    document.getElementById('modeToggle').addEventListener('change', (e) => {
        isMaxHeap = e.target.checked;
        if (heap.length > 0) {
            buildHeap([...heap]); 
            updateStatus(`Switched to ${isMaxHeap ? 'Max' : 'Min'} Heap. Re-heapifying...`);
        } else {
            updateStatus(`Switched to ${isMaxHeap ? 'Max' : 'Min'} Heap.`);
        }
    });

    function disableControls(disabled) {
        document.querySelectorAll('button').forEach(b => b.disabled = disabled);
        document.getElementById('modeToggle').disabled = disabled;
    }

    function updateStatus(msg) {
        document.getElementById('status').textContent = msg;
    }

    // Initial Draw
    drawArray(null);
    updateStatus("Enter a number to insert or a list to heapify.");

</script>
</body>
</html>