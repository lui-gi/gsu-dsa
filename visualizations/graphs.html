<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph BFS/DFS Visualization</title>
    <style>
        /* GSU Color Palette */
        :root {
            --gsu-blue: #0039A6;
            --gsu-dark: #1f2a36;
            --gsu-gray: #777777;
            --light-bg: #f4f4f4;
            --highlight: #CC0000;
            --success: #28a745;
            --warning: #ffc107;
            --node-radius: 20;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: var(--light-bg);
            color: #333;
            user-select: none;
        }

        header {
            background-color: var(--gsu-blue);
            color: white;
            padding: 1rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        h1 { margin: 0; font-size: 1.6rem; }
        p { margin: 5px 0 0; opacity: 0.9; font-size: 0.9rem; }

        /* Controls */
        .controls {
            background: white;
            padding: 1rem;
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            border-bottom: 2px solid #ddd;
            z-index: 10;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #f8f9fa;
            padding: 5px 10px;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }

        button {
            background-color: var(--gsu-blue);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }

        button:hover { background-color: #00256e; }
        button:disabled { background-color: var(--gsu-gray); cursor: not-allowed; }
        button.danger { background-color: var(--highlight); }

        /* Main Layout */
        #main-container {
            display: flex;
            flex-grow: 1;
            padding: 10px;
            gap: 10px;
            overflow: hidden;
        }

        #canvas-wrapper {
            flex-grow: 1;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* Sidebar */
        #sidebar {
            width: 280px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            padding: 15px;
            flex-shrink: 0;
            gap: 10px;
        }

        #sidebar h3 { margin-top: 0; color: var(--gsu-blue); text-align: center; font-size: 1.1rem; margin-bottom: 5px; }
        
        /* Time Counter Box */
        .time-box {
            background: var(--gsu-dark);
            color: white;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
            font-family: monospace;
            font-size: 1.2rem;
            margin-bottom: 5px;
            display: none; /* Hidden unless Topo Sort */
        }

        .data-structure-box {
            flex-grow: 1;
            border: 2px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            background: #fafafa;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-height: 120px;
        }

        .ds-item {
            background: var(--gsu-blue);
            color: white;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
            animation: fadeIn 0.3s ease;
        }

        .ds-item.removing {
            background: var(--highlight);
            animation: fadeOut 0.3s ease;
        }

        .result-section {
            background: white;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 5px;
        }

        .result-box {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 10px;
            background: #fafafa;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-height: 50px;
            align-content: flex-start;
        }

        .result-node {
            width: 32px;
            height: 32px;
            background-color: var(--success);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; transform: scale(0.9); } }
        @keyframes popIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        .log-box {
            height: 120px;
            border-top: 1px solid #ddd;
            padding-top: 10px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.85rem;
            color: #555;
        }

        .instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255,255,255,0.95);
            padding: 10px;
            border-radius: 4px;
            font-size: 0.85rem;
            pointer-events: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 160px;
            height: 34px;
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            font-size: 0.8rem;
            font-weight: bold;
            color: white;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--gsu-blue); }
        input:checked + .slider:before { transform: translateX(126px); }
        .label-off { margin-right: auto; color: #555; z-index: 1; }
        .label-on { margin-left: auto; color: white; z-index: 1; display: none; }
        input:checked + .slider .label-off { display: none; }
        input:checked + .slider .label-on { display: block; }

    </style>
</head>
<body>

<header>
    <h1>Graph Visualizer</h1>
    <p>Build Graphs & Visualize BFS (Queue) vs. DFS (Stack)</p>
</header>

<div class="controls">
    <div class="control-group">
        <label class="toggle-switch">
            <input type="checkbox" id="directedToggle">
            <span class="slider">
                <span class="label-off">Undirected</span>
                <span class="label-on">Directed</span>
            </span>
        </label>
    </div>

    <!-- New Edge Mode Toggle -->
    <div class="control-group">
        <label class="toggle-switch">
            <input type="checkbox" id="edgeModeToggle">
            <span class="slider">
                <span class="label-off">Move</span>
                <span class="label-on">Add Edge</span>
            </span>
        </label>
    </div>

    <div class="control-group">
        <button onclick="runAlgorithm('BFS')">Run BFS</button>
        <button onclick="runAlgorithm('DFS')">Run DFS</button>
        <button onclick="runAlgorithm('Topo')">Run Topo Sort (DFS)</button>
    </div>

    <div class="control-group">
        <button class="danger" onclick="clearGraph()">Clear Graph</button>
    </div>

    <div class="control-group">
        <label style="font-size: 0.8rem;">Speed:</label>
        <input type="range" id="speedRange" min="1" max="10" value="6">
    </div>
    
    <div id="status" style="font-style: italic; color: var(--gsu-blue); font-weight: bold;"></div>
</div>

<div id="main-container">
    <div id="canvas-wrapper">
        <canvas id="graphCanvas"></canvas>
        <div class="instructions">
            <strong>Controls:</strong><br>
            • <strong>Move Mode:</strong> Drag nodes to move. Click empty space to Add Node.<br>
            • <strong>Add Edge Mode:</strong> Drag from one node to another to connect.<br>
            • Click Node to <strong>Select Start</strong> (Yellow)
        </div>
    </div>

    <div id="sidebar">
        <div id="time-display" class="time-box">Time: 0</div>

        <h3 id="ds-title">Data Structure</h3>
        <div id="ds-container" class="data-structure-box">
            <div style="text-align: center; color: #999; margin-top: 50px;">
                Run an algorithm to see the Queue (BFS) or Stack (DFS).
            </div>
        </div>
        
        <div class="result-section">
            <h3 style="font-size: 1rem; color: #555; margin-bottom: 5px;">Traversal/Sort Order</h3>
            <div id="result-box" class="result-box">
                <!-- Result nodes will appear here -->
            </div>
        </div>

        <div id="log-container" class="log-box"></div>
    </div>
</div>

<script>
    // --- State ---
    const nodes = []; // {id, x, y}
    const edges = []; // {from, to}
    let isDirected = false;
    let isEdgeMode = false; // New state for Edge Creation Mode
    let selectedNode = null; 
    let draggingNode = null;
    let creatingEdgeStart = null;
    let mouseX = 0, mouseY = 0;
    let nodeIdCounter = 0;

    // Animation
    let isAnimating = false;
    let animationQueue = [];
    const visitedSet = new Set();
    const nodeTimes = {}; // Stores {start, finish} for each node id

    // Canvas
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    const wrapper = document.getElementById('canvas-wrapper');

    // Config
    const NODE_RADIUS = 20;

    // Resize
    function resize() {
        canvas.width = wrapper.clientWidth;
        canvas.height = wrapper.clientHeight;
        draw();
    }
    window.addEventListener('resize', resize);

    // --- Graph Logic ---

    function addNode(x, y) {
        nodes.push({ id: nodeIdCounter++, x, y });
        if (selectedNode === null) selectedNode = nodes[0];
        draw();
    }

    function addEdge(fromNode, toNode) {
        if (fromNode === toNode) return;
        const exists = edges.some(e => 
            (e.from === fromNode && e.to === toNode) || 
            (!isDirected && e.from === toNode && e.to === fromNode)
        );
        if (!exists) {
            edges.push({ from: fromNode, to: toNode });
        }
        draw();
    }

    function getAdjacencyList() {
        const adj = {};
        nodes.forEach(n => adj[n.id] = []);
        edges.forEach(e => {
            adj[e.from.id].push(e.to.id);
            if (!isDirected) {
                adj[e.to.id].push(e.from.id);
            }
        });
        for (let id in adj) {
            adj[id].sort((a, b) => a - b);
        }
        return adj;
    }

    // --- Algorithms ---

    function runAlgorithm(type) {
        if (nodes.length === 0) return;
        
        if (type === 'Topo') {
            if (!isDirected) {
                alert("Topological Sort requires a Directed Graph. Please toggle 'Directed' on.");
                return;
            }
        } else {
             if (!selectedNode) {
                alert("Please click a node to select it as the Start Node.");
                return;
            }
        }

        if (isAnimating) return;

        // Reset
        visitedSet.clear();
        animationQueue = [];
        
        // Clear Times
        for (let key in nodeTimes) delete nodeTimes[key];

        document.getElementById('log-container').innerHTML = '';
        document.getElementById('ds-container').innerHTML = '';
        document.getElementById('result-box').innerHTML = '';
        
        // UI Toggles
        const dsTitle = document.getElementById('ds-title');
        const timeDisplay = document.getElementById('time-display');
        
        const adj = getAdjacencyList();
        
        if (type === 'BFS') {
            dsTitle.textContent = "Queue (FIFO)";
            timeDisplay.style.display = 'none';
            updateStatus(`Running BFS starting from Node ${selectedNode.id}...`);
            bfs(adj, selectedNode.id);
        } else if (type === 'DFS') {
            dsTitle.textContent = "Stack (LIFO)";
            timeDisplay.style.display = 'none';
            updateStatus(`Running DFS starting from Node ${selectedNode.id}...`);
            dfs(adj, selectedNode.id);
        } else if (type === 'Topo') {
            dsTitle.textContent = "Recursion Stack";
            timeDisplay.style.display = 'block';
            timeDisplay.textContent = "Time: 0";
            updateStatus(`Running Topological Sort (DFS Method)...`);
            topoSortDFS(adj);
        }

        playAnimations();
    }

    function bfs(adj, startId) {
        const queue = [startId];
        const visited = new Set();
        visited.add(startId);

        queueStep('enqueue', startId, `Start: Enqueue Node ${startId}`);
        queueStep('visit', startId, `Visited Node ${startId}`);

        while (queue.length > 0) {
            const current = queue.shift();
            queueStep('dequeue', current, `Dequeue Node ${current}`);
            queueStep('current', current, `Processing Node ${current}`);

            const neighbors = adj[current];
            for (let neighbor of neighbors) {
                if (!visited.has(neighbor)) {
                    visited.add(neighbor);
                    queue.push(neighbor);
                    queueStep('traverse', {from: current, to: neighbor}, `Traversing to ${neighbor}`);
                    queueStep('visit', neighbor, `Visited Node ${neighbor}`);
                    queueStep('enqueue', neighbor, `Enqueue Node ${neighbor}`);
                }
            }
        }
        queueStep('done', null, "BFS Complete");
    }

    function dfs(adj, startId) {
        const stack = [startId];
        const visited = new Set();
        
        queueStep('push', startId, `Start: Push Node ${startId}`);

        while (stack.length > 0) {
            const current = stack.pop();
            queueStep('pop', current, `Pop Node ${current}`);

            if (!visited.has(current)) {
                visited.add(current);
                queueStep('visit', current, `Visited Node ${current}`);
                queueStep('current', current, `Processing Node ${current}`);

                const neighbors = adj[current];
                for (let i = neighbors.length - 1; i >= 0; i--) { 
                    const neighbor = neighbors[i];
                    if (!visited.has(neighbor)) {
                        queueStep('push', neighbor, `Push neighbor ${neighbor}`);
                        stack.push(neighbor);
                        queueStep('traverse', {from: current, to: neighbor}, `Found edge to ${neighbor}`);
                    }
                }
            }
        }
        queueStep('done', null, "DFS Complete");
    }

    function topoSortDFS(adj) {
        let time = 0;
        const visited = new Set();
        const recursionStack = new Set();
        let cycleDetected = false;

        // Visual initialization
        nodes.forEach(n => {
            queueStep('initTime', n.id, null); 
        });

        // Loop over all nodes to handle disconnected graphs
        const sortedNodes = [...nodes].sort((a,b) => a.id - b.id);

        function dfsVisit(u) {
            if (cycleDetected) return;

            visited.add(u);
            recursionStack.add(u);
            
            time++;
            // Log Start Time
            queueStep('timeUpdate', {id: u, start: time, finish: null, global: time}, `Time ${time}: Start processing Node ${u}`);
            queueStep('push', u, `Recursion: Processing Node ${u}`); // Visualize stack push
            queueStep('current', u, `Processing Node ${u}`);

            if (adj[u]) {
                adj[u].forEach(v => {
                    if (recursionStack.has(v)) {
                         cycleDetected = true;
                         queueStep('error', null, `Cycle detected at edge ${u}->${v}!`);
                         return;
                    }
                    if (!visited.has(v)) {
                        queueStep('traverse', {from: u, to: v}, `Traversing to ${v}`);
                        dfsVisit(v);
                    }
                });
            }

            if (cycleDetected) return;

            recursionStack.delete(u);
            time++;
            
            // Log Finish Time
            queueStep('timeUpdate', {id: u, start: null, finish: time, global: time}, `Time ${time}: Finished Node ${u}`);
            queueStep('pop', u, `Recursion: Backtracking from Node ${u}`);
            
            // For Topo Sort: Prepend to result list as we finish
            queueStep('prependResult', u, `Node ${u} Finished. Add to front of Topo Sort.`);
        }

        for (let node of sortedNodes) {
            if (!visited.has(node.id) && !cycleDetected) {
                dfsVisit(node.id);
            }
        }

        if (cycleDetected) {
            queueStep('error', null, "Cycle Detected! Topological Sort impossible.");
        } else {
            queueStep('done', null, "Topological Sort Complete.");
        }
    }

    function queueStep(type, data, msg) {
        animationQueue.push({ type, data, msg });
    }

    // --- Animation Player ---

    async function playAnimations() {
        isAnimating = true;
        const speedInput = document.getElementById('speedRange');
        
        draw(null, null); 

        const wait = () => new Promise(r => setTimeout(r, 1000 - (speedInput.value * 90)));

        const visualVisited = new Set();
        let currentActive = null;

        for (const step of animationQueue) {
            if (step.msg) updateLog(step.msg);

            if (step.type === 'visit') {
                visualVisited.add(step.data);
                addToResult(step.data, false);
            } 
            else if (step.type === 'prependResult') {
                visualVisited.add(step.data); // Mark as fully visited/finished
                addToResult(step.data, true); // True = Prepend
            }
            else if (step.type === 'current') {
                currentActive = step.data;
            } 
            else if (step.type === 'enqueue' || step.type === 'push') {
                addToDS(step.data);
            } 
            else if (step.type === 'dequeue' || step.type === 'pop') {
                removeFromDS(step.data);
            } 
            else if (step.type === 'timeUpdate') {
                // Update Time Counter UI
                document.getElementById('time-display').textContent = `Time: ${step.data.global}`;
                
                // Update Node internal times
                if (!nodeTimes[step.data.id]) nodeTimes[step.data.id] = {start: '?', finish: '?'};
                if (step.data.start !== null) nodeTimes[step.data.id].start = step.data.start;
                if (step.data.finish !== null) nodeTimes[step.data.id].finish = step.data.finish;
            }
            else if (step.type === 'initTime') {
                nodeTimes[step.data] = {start: '?', finish: '?'};
            }
            else if (step.type === 'done') {
                currentActive = null;
                updateStatus("Algorithm Complete.");
            } 
            else if (step.type === 'error') {
                updateStatus("Error: " + step.msg);
                alert(step.msg);
            }

            draw(visualVisited, currentActive);
            await wait();
        }
        isAnimating = false;
    }

    // --- UI Updates ---

    function addToDS(val) {
        const container = document.getElementById('ds-container');
        const item = document.createElement('div');
        item.className = 'ds-item';
        item.textContent = val;
        item.id = `ds-item-${val}`;
        
        // BFS/Topo = Queue-like visualization, DFS = Stack
        // Actually for DFS Recursion stack, appending to bottom looks like call stack growing down
        // Let's stick to: Stack prepends (Top), Queue appends (Bottom)
        // Note: For Topo Sort (Recursion), we used 'push'/'pop'.
        const title = document.getElementById('ds-title').textContent;
        if (title.includes('Queue')) container.appendChild(item);
        else container.prepend(item);
    }

    function removeFromDS(val) {
        const items = document.querySelectorAll('.ds-item');
        for(let item of items) {
             if(item.textContent == val) { 
                 item.classList.add('removing');
                 setTimeout(() => item.remove(), 300);
                 break;
             }
        }
    }

    function addToResult(val, prepend) {
        const box = document.getElementById('result-box');
        const node = document.createElement('div');
        node.className = 'result-node';
        node.textContent = val;
        
        if (prepend) {
            box.prepend(node); // For Topo Sort (Descending finish time)
        } else {
            box.appendChild(node); // For BFS/DFS (Traversal order)
        }
    }

    function updateLog(msg) {
        const log = document.getElementById('log-container');
        const entry = document.createElement('div');
        entry.textContent = `> ${msg}`;
        log.prepend(entry);
    }

    function updateStatus(msg) {
        document.getElementById('status').textContent = msg;
    }

    function clearGraph() {
        if(isAnimating) return;
        nodes.length = 0;
        edges.length = 0;
        nodeIdCounter = 0;
        selectedNode = null;
        for (let key in nodeTimes) delete nodeTimes[key];
        
        document.getElementById('log-container').innerHTML = '';
        document.getElementById('ds-container').innerHTML = '';
        document.getElementById('result-box').innerHTML = '';
        document.getElementById('time-display').style.display = 'none';
        
        draw();
    }

    // --- Canvas Interaction ---

    function getNodeAt(x, y) {
        return nodes.find(n => {
            const dx = n.x - x;
            const dy = n.y - y;
            return Math.sqrt(dx*dx + dy*dy) < NODE_RADIUS;
        });
    }

    canvas.addEventListener('mousedown', e => {
        if(isAnimating) return;
        const rect = canvas.getBoundingClientRect();
        mouseX = e.clientX - rect.left;
        mouseY = e.clientY - rect.top;

        const clickedNode = getNodeAt(mouseX, mouseY);

        if (clickedNode) {
            // Selected a Node
            // Common logic: Always select on click
            selectedNode = clickedNode;

            if (isEdgeMode) {
                // EDGE MODE: Start edge creation
                creatingEdgeStart = clickedNode;
            } else {
                // MOVE MODE: Start dragging/moving
                draggingNode = clickedNode;
            }
        } else {
            // Clicked Empty Space
            if (!isEdgeMode) {
                // Only add nodes in Move Mode
                addNode(mouseX, mouseY);
            }
        }
        draw();
    });

    canvas.addEventListener('mousemove', e => {
        if(isAnimating) return;
        const rect = canvas.getBoundingClientRect();
        mouseX = e.clientX - rect.left;
        mouseY = e.clientY - rect.top;

        if (isEdgeMode) {
             // EDGE MODE Logic
             if (creatingEdgeStart) {
                draw(); // Redraw static
                // Draw temp line
                ctx.beginPath();
                ctx.moveTo(creatingEdgeStart.x, creatingEdgeStart.y);
                ctx.lineTo(mouseX, mouseY);
                ctx.strokeStyle = '#999';
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        } else {
            // MOVE MODE Logic
            if (draggingNode) {
                draggingNode.x = mouseX;
                draggingNode.y = mouseY;
                draw();
            }
        }
    });

    canvas.addEventListener('mouseup', e => {
        if(isAnimating) return;
        
        if (isEdgeMode) {
            if (creatingEdgeStart) {
                const hitNode = getNodeAt(mouseX, mouseY);
                if (hitNode && hitNode !== creatingEdgeStart) {
                    addEdge(creatingEdgeStart, hitNode);
                } 
            }
        }
        
        draggingNode = null;
        creatingEdgeStart = null;
        draw();
    });

    // --- Drawing ---

    function draw(visualVisited = null, currentActive = null) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Edges
        ctx.lineWidth = 2;
        edges.forEach(edge => {
            const start = edge.from;
            const end = edge.to;
            ctx.strokeStyle = '#999';
            drawArrow(start.x, start.y, end.x, end.y, isDirected);
        });

        // Nodes
        nodes.forEach(node => {
            ctx.beginPath();
            ctx.arc(node.x, node.y, NODE_RADIUS, 0, 2 * Math.PI);
            
            if (currentActive === node.id) ctx.fillStyle = '#ff9f43'; 
            else if (visualVisited && visualVisited.has(node.id)) ctx.fillStyle = '#28a745'; 
            else if (selectedNode === node) ctx.fillStyle = '#feca57'; 
            else ctx.fillStyle = 'white';

            ctx.fill();
            
            ctx.strokeStyle = (selectedNode === node) ? '#e67e22' : '#0039A6';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Node ID
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.id, node.x, node.y);

            // Draw Time (d/f) if exists
            if (nodeTimes[node.id]) {
                const t = nodeTimes[node.id];
                ctx.fillStyle = '#cc0000';
                ctx.font = 'bold 11px Arial';
                // Draw 'd/f' to the top-right of the node
                ctx.fillText(`${t.start}/${t.finish}`, node.x + NODE_RADIUS + 5, node.y - NODE_RADIUS + 5);
            }
        });
    }

    function drawArrow(x1, y1, x2, y2, directed) {
        const headLength = 10;
        const angle = Math.atan2(y2 - y1, x2 - x1);
        const startX = x1 + NODE_RADIUS * Math.cos(angle);
        const startY = y1 + NODE_RADIUS * Math.sin(angle);
        const endX = x2 - NODE_RADIUS * Math.cos(angle);
        const endY = y2 - NODE_RADIUS * Math.sin(angle);

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();

        if (directed) {
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - headLength * Math.cos(angle - Math.PI / 6), endY - headLength * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(endX - headLength * Math.cos(angle + Math.PI / 6), endY - headLength * Math.sin(angle + Math.PI / 6));
            ctx.lineTo(endX, endY);
            ctx.fillStyle = '#999';
            ctx.fill();
        }
    }

    document.getElementById('directedToggle').addEventListener('change', e => {
        isDirected = e.target.checked;
        draw();
    });

    document.getElementById('edgeModeToggle').addEventListener('change', e => {
        isEdgeMode = e.target.checked;
    });

    let originalNodePos = {x:0, y:0};
    
    // Initial Setup
    resize();
    addNode(100, 200);
    addNode(300, 100);
    addNode(300, 300);
    addNode(500, 200);
    addEdge(nodes[0], nodes[1]);
    addEdge(nodes[0], nodes[2]);
    addEdge(nodes[1], nodes[3]);
    draw();

</script>
</body>
</html>