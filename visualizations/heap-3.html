<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heap Data Structure Visualization</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0" rel="stylesheet">
    <style>
        /* GSU Material Design Color Palette */
        :root {
            --md-sys-color-primary: #0039A6;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #D7E2FF;
            --md-sys-color-on-primary-container: #001944;
            
            --md-sys-color-secondary: #555F71;
            --md-sys-color-on-secondary: #FFFFFF;
            --md-sys-color-secondary-container: #D9E3F8;
            
            --md-sys-color-error: #BA1A1A;
            --md-sys-color-on-error: #FFFFFF;
            --md-sys-color-error-container: #FFDAD6;
            
            --md-sys-color-warning: #7D5700;
            --md-sys-color-warning-container: #FFDDB3;
            
            --md-sys-color-success: #006E26;
            --md-sys-color-success-container: #96F7AF;
            
            --md-sys-color-surface: #F9F9FF;
            --md-sys-color-surface-variant: #E0E2EC;
            --md-sys-color-on-surface: #1A1B20;
            --md-sys-color-on-surface-variant: #44464F;
            
            --md-sys-color-outline: #74777F;
            --md-sys-color-outline-variant: #C4C6D0;
            
            --md-sys-elevation-1: 0 1px 2px rgba(0,0,0,0.05), 0 1px 3px rgba(0,0,0,0.1);
            --md-sys-elevation-2: 0 2px 4px rgba(0,0,0,0.05), 0 3px 6px rgba(0,0,0,0.1);
            --md-sys-elevation-3: 0 4px 8px rgba(0,0,0,0.05), 0 6px 12px rgba(0,0,0,0.1);
            --md-sys-elevation-4: 0 6px 12px rgba(0,0,0,0.05), 0 8px 16px rgba(0,0,0,0.1);
            
            --node-radius: 22;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* Material App Bar */
        header {
            background-color: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            padding: 16px 24px;
            box-shadow: var(--md-sys-elevation-2);
            z-index: 100;
        }

        .app-bar-content {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            font-size: 22px;
            font-weight: 500;
            letter-spacing: 0.25px;
            margin-bottom: 4px;
        }

        .subtitle {
            font-size: 14px;
            opacity: 0.87;
            letter-spacing: 0.1px;
        }

        /* Material Controls Section */
        .controls {
            background: var(--md-sys-color-surface);
            padding: 16px 24px;
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            box-shadow: var(--md-sys-elevation-1);
            z-index: 90;
        }

        .control-section {
            display: flex;
            gap: 12px;
            align-items: center;
            padding: 8px 16px;
            background: var(--md-sys-color-surface-variant);
            border-radius: 28px;
        }

        /* Material Segmented Button for Heap Type */
        .segmented-button-group {
            display: inline-flex;
            border: 1px solid var(--md-sys-color-outline);
            border-radius: 20px;
            overflow: hidden;
            background: var(--md-sys-color-surface);
        }

        .segmented-button {
            padding: 10px 24px;
            border: none;
            background: transparent;
            color: var(--md-sys-color-on-surface);
            font-family: 'Roboto', sans-serif;
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 0.1px;
            cursor: pointer;
            transition: all 200ms cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .segmented-button:not(:last-child) {
            border-right: 1px solid var(--md-sys-color-outline);
        }

        .segmented-button.active {
            background: var(--md-sys-color-secondary-container);
            color: var(--md-sys-color-on-secondary-container);
        }

        .segmented-button:hover:not(.active) {
            background: rgba(0, 57, 166, 0.08);
        }

        /* Material Text Field */
        .text-field {
            position: relative;
            display: inline-flex;
            flex-direction: column;
        }

        .text-field input {
            padding: 16px 16px 8px;
            border: 1px solid var(--md-sys-color-outline);
            border-radius: 4px;
            font-size: 16px;
            font-family: 'Roboto', sans-serif;
            color: var(--md-sys-color-on-surface);
            background: var(--md-sys-color-surface);
            transition: all 200ms;
            width: 120px;
        }

        .text-field input:focus {
            outline: 2px solid var(--md-sys-color-primary);
            border-color: var(--md-sys-color-primary);
        }

        .text-field label {
            position: absolute;
            left: 16px;
            top: 16px;
            font-size: 16px;
            color: var(--md-sys-color-on-surface-variant);
            transition: all 200ms;
            pointer-events: none;
            background: var(--md-sys-color-surface);
            padding: 0 4px;
        }

        .text-field input:focus + label,
        .text-field input:not(:placeholder-shown) + label {
            top: -8px;
            font-size: 12px;
            color: var(--md-sys-color-primary);
        }

        /* Material Filled Button */
        .md-button {
            padding: 10px 24px;
            border: none;
            border-radius: 20px;
            font-family: 'Roboto', sans-serif;
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 0.1px;
            cursor: pointer;
            transition: all 200ms cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            position: relative;
            overflow: hidden;
        }

        .md-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .md-button:active::before {
            width: 300px;
            height: 300px;
        }

        .md-button-filled {
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            box-shadow: var(--md-sys-elevation-1);
        }

        .md-button-filled:hover {
            box-shadow: var(--md-sys-elevation-2);
            background: #002f8a;
        }

        .md-button-filled:disabled {
            background: rgba(26, 27, 32, 0.12);
            color: rgba(26, 27, 32, 0.38);
            box-shadow: none;
            cursor: not-allowed;
        }

        .md-button-outlined {
            background: transparent;
            color: var(--md-sys-color-primary);
            border: 1px solid var(--md-sys-color-outline);
        }

        .md-button-outlined:hover {
            background: rgba(0, 57, 166, 0.08);
        }

        .md-button-text {
            background: transparent;
            color: var(--md-sys-color-primary);
        }

        .md-button-text:hover {
            background: rgba(0, 57, 166, 0.08);
        }

        /* Material Icon */
        .material-symbols-rounded {
            font-size: 18px;
        }

        /* FAB - Floating Action Button */
        .fab {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 56px;
            height: 56px;
            border-radius: 16px;
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            border: none;
            box-shadow: var(--md-sys-elevation-3);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 200ms cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 50;
        }

        .fab:hover {
            box-shadow: var(--md-sys-elevation-4);
            transform: scale(1.05);
        }

        .fab .material-symbols-rounded {
            font-size: 24px;
        }

        /* Main Container */
        #main-container {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            padding: 16px;
            gap: 16px;
            overflow: hidden;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        /* Material Snackbar */
        .snackbar {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--md-sys-color-on-surface);
            color: var(--md-sys-color-surface);
            padding: 14px 16px;
            border-radius: 4px;
            box-shadow: var(--md-sys-elevation-3);
            font-size: 14px;
            letter-spacing: 0.25px;
            z-index: 1000;
            opacity: 0;
            transition: all 300ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        .snackbar.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Tree View Card */
        #canvas-container {
            flex-grow: 2;
            background: var(--md-sys-color-surface);
            border-radius: 16px;
            box-shadow: var(--md-sys-elevation-1);
            position: relative;
            overflow: hidden;
            border: 1px solid var(--md-sys-color-outline-variant);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Array View Card */
        #array-container {
            flex-grow: 0;
            min-height: 140px;
            background: var(--md-sys-color-surface);
            border-radius: 16px;
            box-shadow: var(--md-sys-elevation-1);
            padding: 20px;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--md-sys-color-outline-variant);
        }

        .array-label {
            font-weight: 500;
            margin-bottom: 16px;
            color: var(--md-sys-color-primary);
            font-size: 16px;
            letter-spacing: 0.15px;
        }

        .array-box {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding-bottom: 12px;
            align-items: center;
            scrollbar-width: thin;
            scrollbar-color: var(--md-sys-color-primary) var(--md-sys-color-surface-variant);
        }

        .array-box::-webkit-scrollbar {
            height: 8px;
        }

        .array-box::-webkit-scrollbar-track {
            background: var(--md-sys-color-surface-variant);
            border-radius: 4px;
        }

        .array-box::-webkit-scrollbar-thumb {
            background: var(--md-sys-color-primary);
            border-radius: 4px;
        }

        /* Material Chip-based Array Cell */
        .array-cell {
            min-width: 52px;
            height: 52px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: 500;
            font-size: 16px;
            color: var(--md-sys-color-primary);
            border-radius: 12px;
            position: relative;
            background: var(--md-sys-color-primary-container);
            transition: all 300ms cubic-bezier(0.4, 0, 0.2, 1);
            flex-shrink: 0;
            box-shadow: var(--md-sys-elevation-1);
            border: 1px solid var(--md-sys-color-outline-variant);
        }

        .array-cell span.idx {
            position: absolute;
            bottom: -22px;
            font-size: 11px;
            color: var(--md-sys-color-on-surface-variant);
            font-weight: 400;
            font-family: 'Roboto Mono', monospace;
        }

        .array-cell.highlight {
            background-color: var(--md-sys-color-error-container);
            color: var(--md-sys-color-error);
            border-color: var(--md-sys-color-error);
            transform: scale(1.1);
            box-shadow: var(--md-sys-elevation-3);
        }
        
        .array-cell.compare {
            background-color: var(--md-sys-color-warning-container);
            color: var(--md-sys-color-warning);
            border-color: var(--md-sys-color-warning);
            box-shadow: var(--md-sys-elevation-2);
        }

        /* Legend */
        .legend {
            position: absolute;
            top: 16px;
            left: 16px;
            background: rgba(255,255,255,0.95);
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 13px;
            box-shadow: var(--md-sys-elevation-2);
            border: 1px solid var(--md-sys-color-outline-variant);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        /* Bottom Sheet */
        .bottom-sheet {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--md-sys-color-surface);
            border-radius: 28px 28px 0 0;
            box-shadow: 0 -4px 16px rgba(0,0,0,0.15);
            transform: translateY(100%);
            transition: transform 300ms cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 200;
            max-height: 60vh;
            overflow-y: auto;
        }

        .bottom-sheet.open {
            transform: translateY(0);
        }

        .bottom-sheet-handle {
            width: 32px;
            height: 4px;
            background: var(--md-sys-color-outline-variant);
            border-radius: 2px;
            margin: 12px auto 8px;
        }

        .bottom-sheet-content {
            padding: 16px 24px 32px;
        }

        .bottom-sheet-title {
            font-size: 24px;
            font-weight: 500;
            margin-bottom: 16px;
            color: var(--md-sys-color-on-surface);
        }

        .bottom-sheet-actions {
            display: flex;
            gap: 12px;
            margin-top: 24px;
            justify-content: flex-end;
        }

        /* Scrim overlay */
        .scrim {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            opacity: 0;
            pointer-events: none;
            transition: opacity 300ms cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 199;
        }

        .scrim.show {
            opacity: 1;
            pointer-events: all;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .controls {
                padding: 12px;
            }
            
            .control-section {
                padding: 6px 12px;
            }

            .fab {
                bottom: 16px;
                right: 16px;
            }

            #main-container {
                padding: 12px;
            }
        }

    </style>
</head>
<body>

<header>
    <div class="app-bar-content">
        <h1>Heap Visualization</h1>
        <p class="subtitle">Interactive Min/Max Heap Data Structure</p>
    </div>
</header>

<div class="controls">
    <div class="segmented-button-group">
        <button class="segmented-button active" id="minHeapBtn" onclick="switchHeapType(false)">
            Min Heap
        </button>
        <button class="segmented-button" id="maxHeapBtn" onclick="switchHeapType(true)">
            Max Heap
        </button>
    </div>

    <div class="control-section">
        <div class="text-field">
            <input type="number" id="numInput" placeholder=" " onkeypress="handleEnter(event)">
            <label>Value</label>
        </div>
        <button class="md-button md-button-filled" onclick="handleAdd()">
            <span class="material-symbols-rounded">add</span>
            Insert
        </button>
    </div>

    <button class="md-button md-button-outlined" onclick="handleRemove()">
        <span class="material-symbols-rounded">remove</span>
        Remove Root
    </button>

    <button class="md-button md-button-outlined" onclick="openHeapifySheet()">
        <span class="material-symbols-rounded">format_list_numbered</span>
        Heapify Array
    </button>

    <button class="md-button md-button-text" onclick="handleClear()">
        <span class="material-symbols-rounded">delete</span>
        Clear
    </button>
</div>

<div id="main-container">
    <div id="canvas-container">
        <canvas id="heapCanvas"></canvas>
        <div class="legend">
            <div class="legend-item">
                <div class="dot" style="background: #0039A6;"></div>
                <span>Normal Node</span>
            </div>
            <div class="legend-item">
                <div class="dot" style="background: #BA1A1A;"></div>
                <span>Active Operation</span>
            </div>
            <div class="legend-item">
                <div class="dot" style="background: #7D5700;"></div>
                <span>Comparing</span>
            </div>
            <div class="legend-item">
                <div class="dot" style="background: #006E26;"></div>
                <span>Success</span>
            </div>
        </div>
    </div>

    <div id="array-container">
        <div class="array-label">Array Representation</div>
        <div class="array-box" id="arrayVisual"></div>
    </div>
</div>

<!-- Bottom Sheet for Heapify -->
<div class="scrim" id="scrim" onclick="closeHeapifySheet()"></div>
<div class="bottom-sheet" id="heapifySheet">
    <div class="bottom-sheet-handle"></div>
    <div class="bottom-sheet-content">
        <h2 class="bottom-sheet-title">Build Heap from Array</h2>
        <p style="margin-bottom: 16px; color: var(--md-sys-color-on-surface-variant);">
            Enter comma-separated numbers to build a heap
        </p>
        <div class="text-field" style="width: 100%;">
            <input type="text" id="heapifyInput" placeholder=" " style="width: 100%;">
            <label>Numbers (e.g., 5,3,8,1,9,2)</label>
        </div>
        <div class="bottom-sheet-actions">
            <button class="md-button md-button-text" onclick="closeHeapifySheet()">Cancel</button>
            <button class="md-button md-button-filled" onclick="handleHeapify()">
                <span class="material-symbols-rounded">build</span>
                Build Heap
            </button>
        </div>
    </div>
</div>

<!-- Snackbar for status messages -->
<div class="snackbar" id="snackbar"></div>

<script>
    // --- Heap Logic and State ---
    const canvas = document.getElementById('heapCanvas');
    const ctx = canvas.getContext('2d');
    const NODE_RADIUS = 22;
    const LEVEL_HEIGHT = 80;

    let heap = [];
    let isMaxHeap = false;
    let animationQueue = [];
    let isAnimating = false;

    // Canvas sizing
    function resizeCanvas() {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        drawTree(null);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Heap helpers
    const getParent = (i) => Math.floor((i - 1) / 2);
    const getLeft = (i) => 2 * i + 1;
    const getRight = (i) => 2 * i + 2;

    function compare(a, b) {
        return isMaxHeap ? a > b : a < b;
    }

    // --- Heap Operations ---

    function insert(value) {
        const val = parseInt(value);
        if (isNaN(val)) return;

        animationQueue.length = 0;
        animationQueue.push({ type: 'insert-start', heapSnapshot: [...heap, val], targets: [heap.length] });
        heap.push(val);

        let idx = heap.length - 1;
        while (idx > 0) {
            const parentIdx = getParent(idx);
            animationQueue.push({ type: 'compare', heapSnapshot: [...heap], targets: [idx, parentIdx] });

            if (compare(heap[idx], heap[parentIdx])) {
                animationQueue.push({ type: 'swap', heapSnapshot: [...heap], targets: [idx, parentIdx], swapIndices: [idx, parentIdx] });
                [heap[idx], heap[parentIdx]] = [heap[parentIdx], heap[idx]];
                idx = parentIdx;
            } else {
                break;
            }
        }

        animationQueue.push({ type: 'success', heapSnapshot: [...heap], targets: [idx] });
        runAnimation();
    }

    function removeRoot() {
        if (heap.length === 0) {
            showSnackbar("Heap is empty!");
            return;
        }

        animationQueue.length = 0;
        animationQueue.push({ type: 'highlight', heapSnapshot: [...heap], targets: [0] });

        const lastIdx = heap.length - 1;
        heap[0] = heap[lastIdx];
        heap.pop();

        if (heap.length === 0) {
            animationQueue.push({ type: 'success', heapSnapshot: [], targets: [] });
            runAnimation();
            return;
        }

        animationQueue.push({ type: 'swap', heapSnapshot: [...heap], targets: [0], swapIndices: null });

        let idx = 0;
        while (true) {
            const leftIdx = getLeft(idx);
            const rightIdx = getRight(idx);
            let targetIdx = idx;

            if (leftIdx < heap.length) {
                animationQueue.push({ type: 'compare', heapSnapshot: [...heap], targets: [idx, leftIdx] });
                if (compare(heap[leftIdx], heap[targetIdx])) {
                    targetIdx = leftIdx;
                }
            }

            if (rightIdx < heap.length) {
                animationQueue.push({ type: 'compare', heapSnapshot: [...heap], targets: [idx, rightIdx] });
                if (compare(heap[rightIdx], heap[targetIdx])) {
                    targetIdx = rightIdx;
                }
            }

            if (targetIdx !== idx) {
                animationQueue.push({ type: 'swap', heapSnapshot: [...heap], targets: [idx, targetIdx], swapIndices: [idx, targetIdx] });
                [heap[idx], heap[targetIdx]] = [heap[targetIdx], heap[idx]];
                idx = targetIdx;
            } else {
                break;
            }
        }

        animationQueue.push({ type: 'success', heapSnapshot: [...heap], targets: [idx] });
        runAnimation();
    }

    function buildHeap(arr) {
        heap = [...arr];
        animationQueue.length = 0;

        for (let i = Math.floor(heap.length / 2) - 1; i >= 0; i--) {
            heapifyDown(i);
        }

        animationQueue.push({ type: 'success', heapSnapshot: [...heap], targets: [] });
        runAnimation();
    }

    function heapifyDown(idx) {
        let current = idx;
        while (true) {
            const leftIdx = getLeft(current);
            const rightIdx = getRight(current);
            let targetIdx = current;

            if (leftIdx < heap.length) {
                animationQueue.push({ type: 'compare', heapSnapshot: [...heap], targets: [current, leftIdx] });
                if (compare(heap[leftIdx], heap[targetIdx])) {
                    targetIdx = leftIdx;
                }
            }

            if (rightIdx < heap.length) {
                animationQueue.push({ type: 'compare', heapSnapshot: [...heap], targets: [current, rightIdx] });
                if (compare(heap[rightIdx], heap[targetIdx])) {
                    targetIdx = rightIdx;
                }
            }

            if (targetIdx !== current) {
                animationQueue.push({ type: 'swap', heapSnapshot: [...heap], targets: [current, targetIdx], swapIndices: [current, targetIdx] });
                [heap[current], heap[targetIdx]] = [heap[targetIdx], heap[current]];
                current = targetIdx;
            } else {
                break;
            }
        }
    }

    // --- Animation Engine ---

    function runAnimation() {
        if (isAnimating || animationQueue.length === 0) return;

        isAnimating = true;
        disableControls(true);

        let stepIndex = 0;
        const processStep = () => {
            if (stepIndex >= animationQueue.length) {
                isAnimating = false;
                disableControls(false);
                drawTree(null);
                drawArray(null);
                return;
            }

            const step = animationQueue[stepIndex++];
            let duration = 500;

            if (step.type === 'compare') duration = 400;
            else if (step.type === 'highlight') duration = 300;
            else if (step.type === 'success') duration = 600;

            drawArray(step);

            if (step.type === 'swap' && step.swapIndices) {
                const [idxA, idxB] = step.swapIndices;
                const positions = calculatePositions(step.heapSnapshot.length);
                const startA = positions[idxA];
                const startB = positions[idxB];

                return new Promise(resolve => {
                    const startTime = performance.now();
                    const animateSwap = (time) => {
                        let progress = (time - startTime) / duration;
                        if (progress > 1) progress = 1;

                        const easeProgress = easeInOutCubic(progress);

                        const movingNodes = {
                            [idxA]: {
                                x: lerp(startA.x, startB.x, easeProgress),
                                y: lerp(startA.y, startB.y, easeProgress)
                            },
                            [idxB]: {
                                x: lerp(startB.x, startA.x, easeProgress),
                                y: lerp(startB.y, startA.y, easeProgress)
                            }
                        };

                        drawTree(step, movingNodes);

                        if (progress < 1) {
                            requestAnimationFrame(animateSwap);
                        } else {
                            resolve();
                            processStep();
                        }
                    };
                    requestAnimationFrame(animateSwap);
                });

            } else {
                drawTree(step);
                setTimeout(processStep, duration);
            }
        };

        processStep();
    }

    function lerp(start, end, t) {
        return start + (end - start) * t;
    }

    function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    // --- Visualization Drawing ---

    function calculatePositions(count) {
        const positions = [];
        if (count === 0) return positions;

        const width = canvas.width;

        const getPos = (idx, x, y, spacing) => {
            positions[idx] = { x, y };
            const leftIdx = getLeft(idx);
            const rightIdx = getRight(idx);

            if (leftIdx < count) {
                getPos(leftIdx, x - spacing/2, y + LEVEL_HEIGHT, spacing/2);
            }
            if (rightIdx < count) {
                getPos(rightIdx, x + spacing/2, y + LEVEL_HEIGHT, spacing/2);
            }
        };

        getPos(0, width/2, 40, width/1.8);
        return positions;
    }

    function drawArray(step) {
        const container = document.getElementById('arrayVisual');
        container.innerHTML = '';

        const data = step ? step.heapSnapshot : heap;

        data.forEach((val, i) => {
            const cell = document.createElement('div');
            cell.className = 'array-cell';
            cell.innerHTML = `${val}<span class="idx">${i}</span>`;

            if (step) {
                if (step.targets.includes(i)) {
                    if (step.type === 'swap' || step.type === 'insert-start') cell.classList.add('highlight');
                    if (step.type === 'compare') cell.classList.add('compare');
                }
            }
            container.appendChild(cell);
        });
    }

    function drawTree(step, movingNodes = null) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const data = step ? step.heapSnapshot : heap;
        if (data.length === 0) return;

        const positions = calculatePositions(data.length);

        // Draw Edges
        positions.forEach((pos, i) => {
            const left = getLeft(i);
            const right = getRight(i);

            ctx.strokeStyle = '#C4C6D0';
            ctx.lineWidth = 2;

            if (left < data.length && positions[left]) {
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(positions[left].x, positions[left].y);
                ctx.stroke();
            }
            if (right < data.length && positions[right]) {
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(positions[right].x, positions[right].y);
                ctx.stroke();
            }
        });

        // Draw Nodes
        positions.forEach((staticPos, i) => {
            let drawPos = staticPos;
            if (movingNodes && movingNodes[i]) {
                drawPos = movingNodes[i];
            }

            let fill = '#0039A6';
            let stroke = '#0039A6';

            if (step && step.targets.includes(i)) {
                if (step.type === 'swap' || step.type === 'insert-start' || step.type === 'highlight') {
                    fill = '#BA1A1A';
                    stroke = '#BA1A1A';
                } else if (step.type === 'compare') {
                    fill = '#7D5700';
                    stroke = '#7D5700';
                } else if (step.type === 'success') {
                    fill = '#006E26';
                    stroke = '#006E26';
                }
            }

            // Material elevation shadow for nodes
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 2;

            ctx.beginPath();
            ctx.arc(drawPos.x, drawPos.y, NODE_RADIUS, 0, 2 * Math.PI);
            ctx.fillStyle = fill;
            ctx.fill();
            
            ctx.shadowColor = 'transparent';
            ctx.strokeStyle = stroke;
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = 'white';
            ctx.font = 'bold 15px Roboto';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(data[i], drawPos.x, drawPos.y);

            if (!movingNodes) {
                ctx.fillStyle = '#74777F';
                ctx.font = '10px Roboto Mono';
                ctx.fillText(i, drawPos.x + NODE_RADIUS + 8, drawPos.y - NODE_RADIUS + 5);
            }
        });
    }

    // --- UI Handlers ---

    function handleAdd() {
        const input = document.getElementById('numInput');
        if (!input.value) return;
        insert(input.value);
        input.value = '';
        input.focus();
    }

    function handleRemove() {
        removeRoot();
    }

    function handleHeapify() {
        const raw = document.getElementById('heapifyInput').value;
        const arr = raw.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
        if (arr.length > 0) {
            buildHeap(arr);
            closeHeapifySheet();
            showSnackbar(`Built ${isMaxHeap ? 'Max' : 'Min'} Heap with ${arr.length} elements`);
        } else {
            showSnackbar("Please enter valid numbers");
        }
    }

    function handleClear() {
        heap = [];
        animationQueue.length = 0;
        drawTree(null);
        drawArray(null);
        showSnackbar("Heap cleared");
    }

    function handleEnter(e) {
        if (e.key === 'Enter') handleAdd();
    }

    function switchHeapType(isMax) {
        isMaxHeap = isMax;
        
        document.getElementById('minHeapBtn').classList.toggle('active', !isMax);
        document.getElementById('maxHeapBtn').classList.toggle('active', isMax);

        if (heap.length > 0) {
            buildHeap([...heap]);
            showSnackbar(`Switched to ${isMax ? 'Max' : 'Min'} Heap`);
        }
    }

    function disableControls(disabled) {
        document.querySelectorAll('button').forEach(b => b.disabled = disabled);
    }

    function openHeapifySheet() {
        document.getElementById('heapifySheet').classList.add('open');
        document.getElementById('scrim').classList.add('show');
    }

    function closeHeapifySheet() {
        document.getElementById('heapifySheet').classList.remove('open');
        document.getElementById('scrim').classList.remove('show');
    }

    function showSnackbar(message) {
        const snackbar = document.getElementById('snackbar');
        snackbar.textContent = message;
        snackbar.classList.add('show');

        setTimeout(() => {
            snackbar.classList.remove('show');
        }, 3000);
    }

    // Initial Draw
    drawArray(null);
    showSnackbar("Enter a value to insert or build a heap from array");

</script>
</body>
</html>