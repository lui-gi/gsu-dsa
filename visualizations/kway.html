<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Way Merge Visualization</title>
    <style>
        :root {
            --primary: #2c3e50;
            --accent: #3498db;
            --highlight: #e74c3c;
            --success: #27ae60;
            --node-size: 60px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f4f6f7;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 { margin-bottom: 10px; color: var(--primary); }
        .citation { font-size: 0.8em; color: #666; margin-bottom: 20px; }

        /* --- Layout --- */
        .main-container {
            display: flex;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
            flex-wrap: wrap;
        }

        .panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        /* --- Controls --- */
        #setup-panel { flex: 1; min-width: 300px; }
        .input-group { margin-bottom: 10px; }
        label { display: block; font-weight: bold; margin-bottom: 5px; }
        input[type="text"] { width: 100%; padding: 8px; box-sizing: border-box; font-family: monospace; }
        button {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            color: white;
            transition: 0.2s;
        }
        .btn-start { background-color: var(--success); }
        .btn-start:disabled { background-color: #bdc3c7; cursor: not-allowed; }
        .btn-reset { background-color: var(--highlight); margin-left: 10px; }
        
        .speed-control { margin-top: 15px; }

        /* --- Visualization Areas --- */
        #viz-panel { flex: 2; min-width: 500px; display: flex; flex-direction: column; gap: 20px; }
        
        /* Lists View */
        .lists-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
            font-family: monospace;
            background: #ecf0f1;
            padding: 10px;
            border-radius: 4px;
        }
        .list-row { display: flex; align-items: center; height: 30px; }
        .list-label { width: 60px; font-weight: bold; }
        .list-items { display: flex; gap: 5px; }
        .list-item {
            padding: 2px 6px;
            border: 1px solid #bdc3c7;
            background: white;
        }
        .list-item.active { background-color: var(--accent); color: white; border-color: var(--primary); }
        .list-item.processed { background-color: #bdc3c7; color: #7f8c8d; }

        /* Heap View */
        .heap-wrapper {
            position: relative;
            height: 300px; /* Fixed height for the tree */
            background: #ffffff;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        .node {
            position: absolute;
            width: var(--node-size);
            height: var(--node-size);
            border-radius: 50%;
            background-color: white;
            border: 2px solid var(--primary);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: all 0.5s ease; /* The magic for real-time swapping */
            z-index: 2;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .node strong { font-size: 1.2em; }
        .node small { font-size: 0.7em; color: #555; }
        
        .node.highlight { border-color: var(--highlight); background-color: #fadbd8; transform: scale(1.1); }
        .node.sorted { border-color: var(--success); background-color: #d5f5e3; }

        /* Result View */
        .result-box {
            min-height: 50px;
            background: #ecf0f1;
            padding: 10px;
            border-radius: 4px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        .result-node {
            padding: 5px 10px;
            background: var(--success);
            color: white;
            border-radius: 4px;
            font-weight: bold;
            animation: popIn 0.3s ease;
        }

        /* Status Bar */
        #status-text {
            font-weight: bold;
            color: var(--accent);
            min-height: 1.2em;
            margin-bottom: 5px;
        }

        @keyframes popIn {
            from { transform: scale(0); }
            to { transform: scale(1); }
        }

    </style>
</head>
<body>

    <h1>K-Way Merge Visualization</h1>
    <div class="citation">Based on provided lecture slides: Step 1 Build Heap [cite: 11], Step 2 Remove Root [cite: 12], Step 3 Insert Next[cite: 13].</div>

    <div class="main-container">
        
        <div id="setup-panel" class="panel">
            <h3>Input Lists (Sorted)</h3>
            <div id="inputs-container">
                </div>
            <div style="margin-top: 10px;">
                <button onclick="addListInput()">+ Add List</button>
            </div>
            
            <hr>
            
            <div class="speed-control">
                <label for="speedRange">Animation Speed (Slow <-> Fast)</label>
                <input type="range" id="speedRange" min="100" max="2000" value="1000" style="direction: rtl">
            </div>

            <div style="margin-top: 20px;">
                <button id="startBtn" class="btn-start" onclick="startMerge()">Start Auto-Play</button>
                <button class="btn-reset" onclick="resetViz()">Reset</button>
            </div>
        </div>

        <div id="viz-panel" class="panel">
            
            <div>
                <div id="status-text">Ready to start...</div>
                <div class="lists-container" id="visual-lists">
                    </div>
            </div>

            <div class="heap-wrapper" id="heap-canvas">
                <div style="position: absolute; top: 10px; left: 10px; color: #999;">Min-Heap Representation</div>
                </div>

            <div>
                <strong>Result Array[cite: 37]:</strong>
                <div class="result-box" id="result-container"></div>
            </div>

        </div>
    </div>

    <script>
        // --- Configuration & State ---
        // Default data from slides 
        const defaultLists = [
            [1, 4, 5],
            [1, 3, 5],
            [2, 6],
            [0, 7, 8]
        ];

        let listsData = []; // The actual arrays
        let listPointers = []; // Track which element is next in each list
        let heap = []; // Internal heap structure
        let isRunning = false;

        // --- DOM Elements ---
        const inputsContainer = document.getElementById('inputs-container');
        const visualListsContainer = document.getElementById('visual-lists');
        const heapCanvas = document.getElementById('heap-canvas');
        const resultContainer = document.getElementById('result-container');
        const statusText = document.getElementById('status-text');
        const startBtn = document.getElementById('startBtn');
        const speedRange = document.getElementById('speedRange');

        // --- Initialization ---
        function initInputs() {
            inputsContainer.innerHTML = '';
            defaultLists.forEach((list, idx) => {
                createInputRow(idx, list.join(', '));
            });
        }

        function createInputRow(idx, value) {
            const div = document.createElement('div');
            div.className = 'input-group';
            div.innerHTML = `
                <label>List ${idx}</label>
                <input type="text" class="list-input" value="${value}" placeholder="1, 2, 3">
            `;
            inputsContainer.appendChild(div);
        }

        function addListInput() {
            const count = document.querySelectorAll('.list-input').length;
            createInputRow(count, '');
        }

        // --- Core Algorithm Helpers ---
        
        // Helper to delay execution for animation
        const sleep = () => new Promise(r => setTimeout(r, parseInt(speedRange.value)));

        // Update status text
        const setStatus = (text) => { statusText.textContent = text; };

        // --- Visualization Rendering ---

        // Render the static lists at the top
        function renderListsState() {
            visualListsContainer.innerHTML = '';
            listsData.forEach((list, listIdx) => {
                const row = document.createElement('div');
                row.className = 'list-row';
                
                const label = document.createElement('div');
                label.className = 'list-label';
                label.textContent = `L${listIdx}:`;
                row.appendChild(label);

                const itemsDiv = document.createElement('div');
                itemsDiv.className = 'list-items';

                list.forEach((val, itemIdx) => {
                    const span = document.createElement('span');
                    span.className = 'list-item';
                    span.textContent = val;
                    
                    // Style logic:
                    // If this item is currently in the heap or processed
                    if (itemIdx < listPointers[listIdx]) {
                        span.classList.add('processed');
                    } else if (itemIdx === listPointers[listIdx]) {
                        // This is the "next available" [cite: 13]
                        // We will highlight it specifically when inserting
                    }
                    
                    // Mark specific item if it's the one currently being added
                    span.id = `list-item-${listIdx}-${itemIdx}`;
                    
                    itemsDiv.appendChild(span);
                });
                row.appendChild(itemsDiv);
                visualListsContainer.appendChild(row);
            });
        }

        // Highlight a specific item in the list view
        function highlightListItem(l, i, state) {
            const el = document.getElementById(`list-item-${l}-${i}`);
            if(!el) return;
            if (state === 'active') el.classList.add('active');
            if (state === 'reset') el.classList.remove('active');
        }

        // --- Heap Visualization Engine ---

        // We use a map to track DOM elements so we can animate them swapping
        // Key: unique ID of the data object. Value: DOM Element.
        const nodeMap = new Map();
        let uniqueIdCounter = 0;

        function createNodeElement(val, listIdx, elemIdx) {
            const id = `node-${uniqueIdCounter++}`;
            const el = document.createElement('div');
            el.className = 'node';
            el.id = id;
            // Display Tuple format as per slides 
            el.innerHTML = `<strong>${val}</strong><small>[${listIdx}, ${elemIdx}]</small>`;
            heapCanvas.appendChild(el);
            return { id, el };
        }

        function getNodePosition(index, totalNodes) {
            // Simple Binary Tree Layout Logic
            // Level 0: 1 node, Level 1: 2 nodes, Level 2: 4 nodes...
            const level = Math.floor(Math.log2(index + 1));
            const levelStartIndex = Math.pow(2, level) - 1;
            const positionInLevel = index - levelStartIndex;
            const nodesInLevel = Math.pow(2, level);
            
            // Width of canvas
            const w = heapCanvas.clientWidth;
            // Height per level
            const levelHeight = 70;
            const startY = 20;

            // X calculation: slice width into sections
            // section width = w / (nodesInLevel + 1) -> No, standard binary tree is better
            // Standard approach: Divide space into 2^level parts
            const section = w / nodesInLevel;
            const x = (positionInLevel * section) + (section / 2) - 30; // -30 is half node width
            const y = startY + (level * levelHeight);

            return { x, y };
        }

        function renderHeapPositions() {
            heap.forEach((nodeObj, index) => {
                const domNode = nodeMap.get(nodeObj.uid);
                const pos = getNodePosition(index, heap.length);
                domNode.style.transform = `translate(${pos.x}px, ${pos.y}px)`;
            });
        }

        // --- Heap Operations with Animation ---

        async function heapSwap(i, j) {
            setStatus(`Swapping indices ${i} and ${j}...`);
            
            // Logic Swap
            let temp = heap[i];
            heap[i] = heap[j];
            heap[j] = temp;

            // Visual Swap (update transforms)
            renderHeapPositions();
            
            // Wait for CSS transition
            await sleep();
        }

        async function siftUp(index) {
            while (index > 0) {
                let parentIndex = Math.floor((index - 1) / 2);
                
                // Compare values (Min-Heap)
                if (heap[index].val < heap[parentIndex].val) {
                    await heapSwap(index, parentIndex);
                    index = parentIndex;
                } else {
                    break;
                }
            }
        }

        async function siftDown(index) {
            let smallest = index;
            const left = 2 * index + 1;
            const right = 2 * index + 2;
            const length = heap.length;

            if (left < length && heap[left].val < heap[smallest].val) {
                smallest = left;
            }
            if (right < length && heap[right].val < heap[smallest].val) {
                smallest = right;
            }

            if (smallest !== index) {
                await heapSwap(index, smallest);
                await siftDown(smallest);
            }
        }

        async function addToHeap(val, listIdx, elemIdx) {
            // Create Visual Node
            const nodeObj = { val, listIdx, elemIdx, uid: uniqueIdCounter };
            const { id, el } = createNodeElement(val, listIdx, elemIdx);
            nodeMap.set(nodeObj.uid, el);

            // 1. Insert at end
            heap.push(nodeObj);
            
            // Initial render (appears at bottom)
            renderHeapPositions();
            await sleep();

            // 2. Sift Up [cite: 21] (Implicitly part of building/maintenance)
            setStatus(`Sifting up ${val}...`);
            await siftUp(heap.length - 1);
        }

        async function removeMin() {
            if (heap.length === 0) return null;

            const minNode = heap[0];
            const minDom = nodeMap.get(minNode.uid);

            // Visual: Highlight root
            minDom.classList.add('highlight');
            setStatus(`Step 2: Remove root [${minNode.val}, ${minNode.listIdx}, ${minNode.elemIdx}] [cite: 35]`);
            await sleep();

            // Visual: Move to result container (We delete from heap canvas and append new element to result)
            minDom.style.opacity = '0'; // Fade out from tree
            
            // Logic: Replace root with last element
            const lastNode = heap.pop();
            
            if (heap.length > 0) {
                heap[0] = lastNode;
                setStatus("Moving last node to root...");
                renderHeapPositions(); // Snap last node to root visual position
                await sleep();
                
                setStatus("Step 3 (Balance): Sifting down... [cite: 103]");
                await siftDown(0);
            }

            // Cleanup removed node from map and canvas
            nodeMap.delete(minNode.uid);
            setTimeout(() => minDom.remove(), 500);

            // Add to Result View
            const resNode = document.createElement('div');
            resNode.className = 'result-node';
            resNode.textContent = minNode.val;
            resultContainer.appendChild(resNode);

            return minNode;
        }

        // --- Main Controller ---

        async function startMerge() {
            if (isRunning) return;
            isRunning = true;
            startBtn.disabled = true;
            
            // 1. Parse Inputs
            listsData = [];
            listPointers = [];
            heap = [];
            heapCanvas.innerHTML = '';
            resultContainer.innerHTML = '';
            nodeMap.clear();
            uniqueIdCounter = 0;

            const inputs = document.querySelectorAll('.list-input');
            inputs.forEach(inp => {
                // Parse "1, 4, 5" into [1, 4, 5]
                const arr = inp.value.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
                listsData.push(arr);
                listPointers.push(0);
            });

            renderListsState();

            // Step 1: Build initial heap [cite: 11]
            setStatus("Step 1: Build min-heap from first column [cite: 11]");
            for (let i = 0; i < listsData.length; i++) {
                if (listsData[i].length > 0) {
                    const val = listsData[i][0];
                    highlightListItem(i, 0, 'active');
                    await addToHeap(val, i, 0);
                    highlightListItem(i, 0, 'reset');
                    listPointers[i]++; // Advance pointer
                    renderListsState();
                }
            }

            // Step 4: Loop until empty [cite: 14]
            while (heap.length > 0) {
                // Step 2: Remove Root [cite: 12]
                const extracted = await removeMin();

                // Step 3: Insert next from same list [cite: 13]
                const listIndex = extracted.listIdx;
                const nextElemIndex = listPointers[listIndex];

                if (nextElemIndex < listsData[listIndex].length) {
                    const nextVal = listsData[listIndex][nextElemIndex];
                    setStatus(`Step 3: Insert next available number (${nextVal}) from List ${listIndex} [cite: 47]`);
                    
                    highlightListItem(listIndex, nextElemIndex, 'active');
                    await sleep(); // Let user see which one is picked
                    
                    await addToHeap(nextVal, listIndex, nextElemIndex);
                    
                    highlightListItem(listIndex, nextElemIndex, 'reset');
                    listPointers[listIndex]++;
                    renderListsState();
                } else {
                    setStatus(`List ${listIndex} is empty. No insertion.`);
                    await sleep();
                }
            }

            setStatus("Merge Complete! Result is sorted.");
            isRunning = false;
            startBtn.disabled = false;
        }

        function resetViz() {
            location.reload();
        }

        // Run Init
        initInputs();

    </script>
</body>
</html>