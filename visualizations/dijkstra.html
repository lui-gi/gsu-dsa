<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra's Algorithm Visualization</title>
    <style>
        /* GSU Color Palette & Basic Reset */
        :root {
            --gsu-blue: #0039A6;
            --gsu-dark: #1f2a36;
            --gsu-gray: #777777;
            --light-bg: #f4f4f4;
            --highlight: #CC0000;
            --success: #28a745;
            --warning: #ffc107;
            --node-radius: 22;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: var(--light-bg);
            color: #333;
            user-select: none;
        }

        header {
            background-color: var(--gsu-blue);
            color: white;
            padding: 1rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        h1 { margin: 0; font-size: 1.6rem; }
        p { margin: 5px 0 0; opacity: 0.9; font-size: 0.9rem; }

        /* Controls */
        .controls {
            background: white;
            padding: 1rem;
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            border-bottom: 2px solid #ddd;
            z-index: 10;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #f8f9fa;
            padding: 5px 10px;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }

        button {
            background-color: var(--gsu-blue);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }

        button:hover { background-color: #00256e; }
        button:disabled { background-color: var(--gsu-gray); cursor: not-allowed; }
        button.danger { background-color: var(--highlight); }

        /* Main Layout */
        #main-container {
            display: flex;
            flex-grow: 1;
            padding: 10px;
            gap: 10px;
            overflow: hidden;
        }

        #canvas-wrapper {
            flex-grow: 1;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* Sidebar */
        #sidebar {
            width: 350px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            padding: 15px;
            flex-shrink: 0;
            gap: 15px;
        }

        #sidebar h3 { margin-top: 0; color: var(--gsu-blue); text-align: center; font-size: 1.1rem; margin-bottom: 5px; }

        /* Dijkstra Table */
        .table-container {
            flex-grow: 1;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        th {
            background-color: var(--gsu-blue);
            color: white;
            padding: 8px;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        td {
            padding: 8px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }

        tr:nth-child(even) { background-color: #f9f9f9; }
        
        tr.highlight-row { background-color: #fff3cd !important; }
        
        .val-update {
            color: var(--highlight);
            font-weight: bold;
            animation: popIn 0.3s ease;
        }

        .log-box {
            height: 100px;
            border-top: 1px solid #ddd;
            padding-top: 10px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.85rem;
            color: #555;
            background: #fafafa;
            padding: 10px;
            border-radius: 4px;
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 150px;
            height: 34px;
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            font-size: 0.8rem;
            font-weight: bold;
            color: white;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--gsu-blue); }
        input:checked + .slider:before { transform: translateX(116px); }
        .label-off { margin-right: auto; color: #555; z-index: 1; }
        .label-on { margin-left: auto; color: white; z-index: 1; display: none; }
        input:checked + .slider .label-off { display: none; }
        input:checked + .slider .label-on { display: block; }

        @keyframes popIn { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }

        /* Modal for Weight Input */
        #weightModal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .modal-content input {
            padding: 8px;
            font-size: 1rem;
            width: 80px;
            margin-bottom: 10px;
        }

    </style>
</head>
<body>

<header>
    <h1>Dijkstra's Algorithm</h1>
    <p>Shortest Path Visualization</p>
</header>

<div class="controls">
    <div class="control-group">
        <label class="toggle-switch">
            <input type="checkbox" id="edgeModeToggle">
            <span class="slider">
                <span class="label-off">Move Node</span>
                <span class="label-on">Add Edge</span>
            </span>
        </label>
    </div>

    <div class="control-group">
        <button onclick="runDijkstra()">Run Dijkstra</button>
        <button class="danger" onclick="resetGraph()">Reset Graph</button>
    </div>

    <div class="control-group">
        <label style="font-size: 0.8rem;">Speed:</label>
        <input type="range" id="speedRange" min="1" max="10" value="6">
    </div>

    <div id="status" style="font-style: italic; color: var(--gsu-blue); font-weight: bold;">Select a Start Node (Click)</div>
</div>

<div id="main-container">
    <div id="canvas-wrapper">
        <canvas id="graphCanvas"></canvas>
    </div>

    <div id="sidebar">
        <h3>Dijkstra Table</h3>
        <div class="table-container">
            <table id="dijkstraTable">
                <thead>
                    <tr>
                        <th>Node</th>
                        <th>Weight</th>
                        <th>Previous</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Populated by JS -->
                </tbody>
            </table>
        </div>
        
        <div id="log-container" class="log-box"></div>
    </div>
</div>

<!-- Weight Input Modal -->
<div id="weightModal">
    <div class="modal-content">
        <h3>Enter Edge Weight</h3>
        <input type="number" id="weightInput" min="1" value="1">
        <br>
        <button onclick="confirmEdge()">Add</button>
        <button class="danger" onclick="cancelEdge()">Cancel</button>
    </div>
</div>

<script>
    // --- Graph Data ---
    // Pre-loaded from Slides (Slide 10/17/22)
    const nodes = [
        {id: 0, x: 200, y: 100},
        {id: 1, x: 400, y: 100},
        {id: 2, x: 100, y: 300}, // Start Node in Slide
        {id: 3, x: 300, y: 300},
        {id: 4, x: 200, y: 450}, // Middle bottomish
        {id: 5, x: 500, y: 300}
    ];

    const edges = [
        {from: 2, to: 0, weight: 8},
        {from: 2, to: 3, weight: 4},
        {from: 2, to: 4, weight: 2},
        {from: 0, to: 1, weight: 2},
        {from: 4, to: 3, weight: 1},
        {from: 4, to: 5, weight: 12},
        {from: 3, to: 0, weight: 3},
        {from: 1, to: 5, weight: 7}
    ];

    // --- State ---
    let selectedNode = nodes[2]; // Default start node is 2 per slides
    let isEdgeMode = false;
    let draggingNode = null;
    let creatingEdgeStart = null;
    let tempEdgeTo = null; // For modal handling
    
    // Animation
    let isAnimating = false;
    let animationQueue = [];
    
    // Dijkstra State
    let dist = {};
    let prev = {};
    let visited = new Set();
    
    // Canvas
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    const wrapper = document.getElementById('canvas-wrapper');
    const NODE_RADIUS = 22;

    function resize() {
        canvas.width = wrapper.clientWidth;
        canvas.height = wrapper.clientHeight;
        draw();
    }
    window.addEventListener('resize', resize);

    // --- Drawing ---

    function draw(activeNode = null, neighborNode = null, pathEdge = null) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Edges
        edges.forEach(edge => {
            const start = nodes.find(n => n.id === edge.from);
            const end = nodes.find(n => n.id === edge.to);
            
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#999';

            // Highlight Edge if active check
            if (pathEdge && pathEdge.from === edge.from && pathEdge.to === edge.to) {
                ctx.strokeStyle = '#8e44ad'; // Purple for checking
                ctx.lineWidth = 4;
            }

            drawArrow(start.x, start.y, end.x, end.y);
            
            // Draw Weight
            const midX = (start.x + end.x) / 2;
            const midY = (start.y + end.y) / 2;
            
            // White circle bg for text
            ctx.beginPath();
            ctx.arc(midX, midY, 10, 0, 2 * Math.PI);
            ctx.fillStyle = 'white';
            ctx.fill();
            
            ctx.fillStyle = '#CC0000';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(edge.weight, midX, midY);
        });

        // Temp Edge Line
        if (isEdgeMode && creatingEdgeStart) {
             const mx = draggingNode ? draggingNode.x : mouseX; // fallback
             // We track mouseX globally in mousemove
             ctx.beginPath();
             ctx.moveTo(creatingEdgeStart.x, creatingEdgeStart.y);
             ctx.lineTo(mouseX, mouseY);
             ctx.strokeStyle = '#999';
             ctx.setLineDash([5, 5]);
             ctx.stroke();
             ctx.setLineDash([]);
        }

        // Nodes
        nodes.forEach(node => {
            ctx.beginPath();
            ctx.arc(node.x, node.y, NODE_RADIUS, 0, 2 * Math.PI);

            // Fill
            if (activeNode === node.id) ctx.fillStyle = '#ff9f43'; // Orange (Current)
            else if (neighborNode === node.id) ctx.fillStyle = '#a29bfe'; // Light Purple (Neighbor)
            else if (visited.has(node.id)) ctx.fillStyle = '#28a745'; // Green (Visited)
            else if (selectedNode === node) ctx.fillStyle = '#feca57'; // Yellow (Start)
            else ctx.fillStyle = 'white';

            ctx.fill();

            // Stroke
            ctx.strokeStyle = (selectedNode === node) ? '#e67e22' : '#0039A6';
            ctx.lineWidth = 2;
            ctx.stroke();

            // ID
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.id, node.x, node.y);
        });
    }

    function drawArrow(x1, y1, x2, y2) {
        const headLength = 10;
        const angle = Math.atan2(y2 - y1, x2 - x1);
        const startX = x1 + NODE_RADIUS * Math.cos(angle);
        const startY = y1 + NODE_RADIUS * Math.sin(angle);
        const endX = x2 - NODE_RADIUS * Math.cos(angle);
        const endY = y2 - NODE_RADIUS * Math.sin(angle);

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo(endX - headLength * Math.cos(angle - Math.PI / 6), endY - headLength * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(endX - headLength * Math.cos(angle + Math.PI / 6), endY - headLength * Math.sin(angle + Math.PI / 6));
        ctx.lineTo(endX, endY);
        ctx.fillStyle = ctx.strokeStyle;
        ctx.fill();
    }

    // --- Dijkstra Logic ---

    function runDijkstra() {
        if (!selectedNode) { alert("Select a start node first!"); return; }
        if (isAnimating) return;

        // Init
        dist = {};
        prev = {};
        visited.clear();
        animationQueue = [];
        
        nodes.forEach(n => {
            dist[n.id] = Infinity;
            prev[n.id] = null;
        });
        dist[selectedNode.id] = 0;

        document.getElementById('log-container').innerHTML = '';
        initTable();
        queueStep('init', null, `Initialized. Start Node: ${selectedNode.id}`);

        // Simple Dijkstra Implementation (O(V^2) for this small graph is fine)
        let unvisited = new Set(nodes.map(n => n.id));

        while (unvisited.size > 0) {
            // Find unvisited node with smallest distance
            let current = null;
            let minDist = Infinity;
            
            unvisited.forEach(id => {
                if (dist[id] < minDist) {
                    minDist = dist[id];
                    current = id;
                }
            });

            // If remaining nodes are unreachable
            if (current === null || minDist === Infinity) break;

            unvisited.delete(current);
            queueStep('current', current, `Visited Node ${current} (Smallest Dist: ${minDist})`);

            // Check Neighbors
            const currentEdges = edges.filter(e => e.from === current);
            
            for (let edge of currentEdges) {
                const neighbor = edge.to;
                if (visited.has(neighbor)) continue;

                queueStep('check', {u: current, v: neighbor}, `Checking path ${current} -> ${neighbor}`);
                
                const alt = dist[current] + edge.weight;
                if (alt < dist[neighbor]) {
                    dist[neighbor] = alt;
                    prev[neighbor] = current;
                    queueStep('update', {id: neighbor, w: alt, p: current}, `Updated Node ${neighbor}: Dist=${alt}, Prev=${current}`);
                }
            }

            visited.add(current);
            queueStep('visit', current, `Finished processing Node ${current}`);
        }

        queueStep('done', null, "Algorithm Complete");
        playAnimations();
    }

    function queueStep(type, data, msg) {
        animationQueue.push({type, data, msg});
    }

    // --- Animation ---

    async function playAnimations() {
        isAnimating = true;
        const speedInput = document.getElementById('speedRange');
        
        // Helper to update log
        const log = (msg) => {
             const div = document.createElement('div');
             div.textContent = `> ${msg}`;
             const container = document.getElementById('log-container');
             container.prepend(div);
        };

        const wait = () => new Promise(r => setTimeout(r, 1500 - (speedInput.value * 140)));

        let activeNode = null;
        let neighborNode = null;
        let pathEdge = null;
        // Temporary visited set for visual building
        const visualVisited = new Set();

        for (let step of animationQueue) {
            log(step.msg);

            if (step.type === 'init') {
                updateTableUI();
            } else if (step.type === 'current') {
                activeNode = step.data;
                neighborNode = null;
                pathEdge = null;
            } else if (step.type === 'check') {
                neighborNode = step.data.v;
                pathEdge = {from: step.data.u, to: step.data.v};
            } else if (step.type === 'update') {
                // Update internal data for table render
                dist[step.data.id] = step.data.w;
                prev[step.data.id] = step.data.p;
                updateTableUI(step.data.id); // Highlight this row
            } else if (step.type === 'visit') {
                visualVisited.add(step.data);
                // Also sync global visited set for draw function usage if needed
                visited.add(step.data);
                pathEdge = null;
                neighborNode = null;
            } else if (step.type === 'done') {
                activeNode = null;
            }

            draw(activeNode, neighborNode, pathEdge);
            await wait();
        }
        isAnimating = false;
        draw();
    }

    // --- Table UI ---

    function initTable() {
        updateTableUI();
    }

    function updateTableUI(highlightId = -1) {
        const tbody = document.querySelector('#dijkstraTable tbody');
        tbody.innerHTML = '';
        
        nodes.forEach(n => {
            const tr = document.createElement('tr');
            if (n.id === highlightId) tr.classList.add('highlight-row');
            
            const w = (dist[n.id] === undefined || dist[n.id] === Infinity) ? '+inf' : dist[n.id];
            const p = (prev[n.id] === undefined || prev[n.id] === null) ? 'null' : prev[n.id];
            
            tr.innerHTML = `
                <td>${n.id}</td>
                <td class="${n.id === highlightId ? 'val-update' : ''}">${w}</td>
                <td class="${n.id === highlightId ? 'val-update' : ''}">${p}</td>
            `;
            tbody.appendChild(tr);
        });
    }

    // --- Interactions ---

    let mouseX = 0, mouseY = 0;

    function getNodeAt(x, y) {
        return nodes.find(n => {
            const dx = n.x - x;
            const dy = n.y - y;
            return Math.sqrt(dx*dx + dy*dy) < NODE_RADIUS;
        });
    }

    canvas.addEventListener('mousemove', e => {
        if (isAnimating) return;
        const rect = canvas.getBoundingClientRect();
        mouseX = e.clientX - rect.left;
        mouseY = e.clientY - rect.top;

        if (isEdgeMode && creatingEdgeStart) {
            draw(); 
        } else if (draggingNode) {
            draggingNode.x = mouseX;
            draggingNode.y = mouseY;
            draw();
        }
    });

    canvas.addEventListener('mousedown', e => {
        if (isAnimating) return;
        const node = getNodeAt(mouseX, mouseY);

        if (node) {
            // Select logic
            selectedNode = node;
            updateStatus(`Start Node: ${node.id}`);

            if (isEdgeMode) {
                creatingEdgeStart = node;
            } else {
                draggingNode = node;
            }
        }
        draw();
    });

    canvas.addEventListener('mouseup', e => {
        if (isAnimating) return;
        if (isEdgeMode && creatingEdgeStart) {
            const target = getNodeAt(mouseX, mouseY);
            if (target && target !== creatingEdgeStart) {
                // Open Modal
                tempEdgeTo = target;
                document.getElementById('weightModal').style.display = 'flex';
                document.getElementById('weightInput').focus();
            }
        }
        draggingNode = null;
        creatingEdgeStart = null;
        draw();
    });

    function confirmEdge() {
        const w = parseInt(document.getElementById('weightInput').value);
        if (creatingEdgeStart && tempEdgeTo && !isNaN(w)) {
            // Remove existing if exists
            const existingIdx = edges.findIndex(e => e.from === creatingEdgeStart.id && e.to === tempEdgeTo.id);
            if(existingIdx > -1) edges.splice(existingIdx, 1);
            
            edges.push({from: creatingEdgeStart.id, to: tempEdgeTo.id, weight: w});
        }
        document.getElementById('weightModal').style.display = 'none';
        draw();
    }

    function cancelEdge() {
        document.getElementById('weightModal').style.display = 'none';
        draw();
    }

    document.getElementById('edgeModeToggle').addEventListener('change', e => {
        isEdgeMode = e.target.checked;
    });

    function updateStatus(msg) {
        document.getElementById('status').textContent = msg;
    }

    function resetGraph() {
        if(isAnimating) return;
        location.reload(); // Simplest way to restore slide state
    }

    // Init
    resize();
    initTable(); // Show initial infinite table
    draw();

</script>
</body>
</html>