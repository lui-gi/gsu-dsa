<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AVL Tree - gsu dsa</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    <style>
        :root {
            --gsu-blue: #0039A6;
            --gsu-blue-light: #4d8dff;
            --text-main: #ffffff;
            --text-muted: #94a3b8;
            --glass-bg: rgba(15, 23, 42, 0.65);
            --glass-border: rgba(255, 255, 255, 0.15);
            
            /* Node Colors */
            --node-normal: #0039A6;
            --node-compare: #ffc107;
            --node-success: #28a745;
            --node-imbalance: #ff4757; /* Red for imbalance */
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #000c24;
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        /* --- BACKGROUND AURA --- */
        .aura-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            filter: blur(80px);
            opacity: 0.6;
            pointer-events: none;
        }
        .aura-blob {
            position: absolute;
            border-radius: 50%;
            mix-blend-mode: screen;
            animation: float 20s infinite ease-in-out alternate;
        }
        .blob-1 { background: var(--gsu-blue); width: 700px; height: 700px; top: -10%; left: -10%; animation-duration: 25s; }
        .blob-2 { background: #0055CC; width: 600px; height: 600px; bottom: -10%; right: -20%; animation-delay: -5s; animation-duration: 30s; }
        .blob-3 { background: #001F5C; width: 800px; height: 800px; bottom: -20%; left: 20%; opacity: 0.8; animation-delay: -10s; }
        @keyframes float {
            0% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(50px, 50px) scale(1.1); }
            100% { transform: translate(-30px, -20px) scale(0.9); }
        }

        /* --- MAIN GLASS CONTAINER --- */
        .main-glass-card {
            width: 100%;
            max-width: 1600px;
            height: 95vh;
            background: var(--glass-bg);
            backdrop-filter: blur(40px) saturate(180%);
            -webkit-backdrop-filter: blur(40px) saturate(180%);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 40px 80px -20px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        /* --- HEADER & CONTROLS --- */
        header {
            padding: 20px 30px;
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(255, 255, 255, 0.03);
            z-index: 20;
        }

        .header-left { display: flex; align-items: center; gap: 20px; }
        
        h1 {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-main);
            letter-spacing: -0.5px;
        }

        .back-btn {
            color: var(--gsu-blue-light);
            text-decoration: none;
            font-weight: 500;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            border: 1px solid var(--glass-border);
            transition: all 0.2s;
        }
        .back-btn:hover { background: rgba(255,255,255,0.1); border-color: var(--text-muted); }

        .controls-toolbar {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            gap: 8px;
            align-items: center;
            padding-left: 12px;
            border-left: 1px solid var(--glass-border);
        }
        .control-group:first-child { border-left: none; padding-left: 0; }

        input[type="number"] {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            color: white;
            padding: 10px 14px;
            border-radius: 10px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            width: 90px;
            outline: none;
            transition: border-color 0.2s;
        }
        input:focus { border-color: var(--gsu-blue-light); }

        button {
            background: rgba(255,255,255,0.08);
            color: white;
            border: 1px solid var(--glass-border);
            padding: 10px 18px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 500;
            font-size: 13px;
            font-family: 'Inter', sans-serif;
            transition: all 0.2s;
        }
        button:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-1px);
        }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        button.primary { background: var(--gsu-blue); border-color: var(--gsu-blue); }
        button.primary:hover { background: #004BC9; }

        button.danger {
            background: rgba(204, 0, 0, 0.2);
            border-color: rgba(204, 0, 0, 0.4);
            color: #ff6b6b;
        }
        button.danger:hover { background: rgba(204, 0, 0, 0.3); border-color: #ff6b6b; }

        /* Rotation Control */
        #rotation-control {
            animation: pulseGlow 1.5s ease-in-out infinite;
        }

        @keyframes pulseGlow {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.85; transform: scale(1.05); }
        }

        #rotateBtn {
            background: linear-gradient(135deg, var(--gsu-blue), #0055CC);
            border-color: var(--gsu-blue);
            box-shadow: 0 4px 15px rgba(0, 57, 166, 0.4);
            font-weight: 600;
        }

        #rotateBtn:hover {
            background: linear-gradient(135deg, #004BC9, #0066DD);
            box-shadow: 0 6px 20px rgba(0, 57, 166, 0.6);
        }

        /* --- CANVAS AREA --- */
        #canvas-wrapper {
            flex-grow: 1;
            position: relative;
            background: rgba(0,0,0,0.2);
            overflow: hidden;
            cursor: grab;
            z-index: 1;
        }
        #canvas-wrapper:active { cursor: grabbing; }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .zoom-btn {
            width: 40px; height: 40px; padding: 0;
            display: flex; align-items: center; justify-content: center;
            font-size: 18px;
            background: rgba(15, 23, 42, 0.8);
            border-color: var(--glass-border);
            border-radius: 10px;
        }
        .zoom-btn:hover { background: rgba(255,255,255,0.1); }

        .legend {
            position: absolute;
            top: 20px; left: 20px;
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(10px);
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 12px;
            color: var(--text-muted);
            pointer-events: none;
        }
        .legend-item { display: flex; align-items: center; gap: 8px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; box-shadow: 0 0 8px currentColor; }

        .status-message {
            position: absolute;
            top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid var(--gsu-blue-light);
            color: var(--gsu-blue-light);
            padding: 10px 24px; border-radius: 20px;
            font-size: 14px; pointer-events: none;
            opacity: 0; transition: opacity 0.3s;
            z-index: 1000; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .status-message.show { opacity: 1; }

        /* --- BOTTOM PANEL (Traversal / Stats) --- */
        #bottom-panel {
            height: 140px;
            min-height: 140px;
            border-top: 1px solid var(--glass-border);
            background: rgba(0,0,0,0.2);
            padding: 10px 30px;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* Stats View */
        #stats-view {
            display: flex;
            height: 100%;
            justify-content: center;
            align-items: center;
            gap: 40px;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 15px 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 120px;
        }
        .stat-val {
            font-size: 24px;
            font-weight: 700;
            color: white;
            margin-bottom: 4px;
        }
        .stat-label {
            font-size: 12px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* --- DISCLAIMER MODAL --- */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .disclaimer-modal {
            background: var(--glass-bg);
            backdrop-filter: blur(40px) saturate(180%);
            -webkit-backdrop-filter: blur(40px) saturate(180%);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 32px 40px;
            max-width: 560px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            text-align: center;
        }

        .disclaimer-modal h2 {
            font-size: 22px;
            font-weight: 700;
            color: var(--gsu-blue-light);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .disclaimer-modal p {
            font-size: 15px;
            line-height: 1.7;
            color: var(--text-muted);
            margin-bottom: 16px;
        }

        .disclaimer-modal .github-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.08);
            color: var(--text-main);
            text-decoration: none;
            padding: 12px 20px;
            border-radius: 10px;
            border: 1px solid var(--glass-border);
            font-weight: 500;
            font-size: 14px;
            transition: all 0.2s;
            margin: 12px 8px;
        }

        .disclaimer-modal .github-link:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 57, 166, 0.3);
        }

        .disclaimer-modal .close-btn {
            background: var(--gsu-blue);
            color: white;
            border: 1px solid var(--gsu-blue);
            padding: 12px 32px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            transition: all 0.2s;
            margin-top: 8px;
        }

        .disclaimer-modal .close-btn:hover {
            background: #004BC9;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 57, 166, 0.5);
        }

    </style>
</head>
<body>

    <div class="aura-container">
        <div class="aura-blob blob-1"></div>
        <div class="aura-blob blob-2"></div>
        <div class="aura-blob blob-3"></div>
    </div>

    <!-- Disclaimer Modal -->
    <div class="modal-overlay" id="disclaimerModal">
        <div class="disclaimer-modal">
            <h2>
                <i class="fa-solid fa-info-circle"></i>
                Disclaimer
            </h2>
            <p>
                This AVL tree visualization is <strong>most effective for understanding simple rotations</strong> with smaller trees.
            </p>
            <p>
                Complex trees <strong>exceeding 10 nodes</strong> may be harder to follow due to the animation complexity and overlapping nodes.
            </p>
            <p>
                Thus, contributions are very welcome! Remember, this project is <strong>open source</strong>! Help us improve the visualizations for our fellow peers! -Luigi
            </p>
            <a href="https://github.com/lui-gi/gsu-dsa" target="_blank" class="github-link">
                <i class="fa-brands fa-github" style="font-size: 18px;"></i>
                View on GitHub
            </a>
            <br>
            <button class="close-btn" onclick="closeDisclaimer()">Got It!</button>
        </div>
    </div>

    <div class="main-glass-card">
        <header>
            <div class="header-left">
                <a href="#" class="back-btn" onclick="window.parent.closeIframe(); return false;">‚Üê Back</a>
                <h1><i class="fa-solid fa-scale-balanced" style="margin-right: 12px; color: var(--gsu-blue-light);"></i>AVL Tree</h1>
            </div>
            
            <div class="controls-toolbar">
                <div class="control-group">
                    <input type="number" id="valInput" placeholder="Value" onkeypress="handleEnter(event)">
                    <button class="primary" onclick="handleInsert()">Insert</button>
                    <button class="danger" onclick="handleDelete()">Delete</button>
                    <button onclick="handleFind()">Find</button>
                </div>

                <div class="control-group">
                    <button onclick="handleRandom()">Random</button>
                    <button onclick="handleClear()">Clear</button>
                </div>

                <div class="control-group" id="rotation-control" style="display: none;">
                    <button class="primary" id="rotateBtn" onclick="executeRotation()">Rotate</button>
                </div>
            </div>
        </header>

        <div id="canvas-wrapper">
            <canvas id="treeCanvas"></canvas>

            <div class="status-message" id="statusMessage"></div>

            <div class="legend">
                <div class="legend-item"><div class="dot" style="color: var(--node-normal); background: currentColor;"></div>Balanced</div>
                <div class="legend-item"><div class="dot" style="color: var(--node-imbalance); background: currentColor;"></div>Rotating/Imbalanced</div>
                <div class="legend-item"><div class="dot" style="color: var(--node-success); background: currentColor;"></div>Inserted/Success</div>
            </div>

            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomIn()"><i class="fa-solid fa-plus"></i></button>
                <button class="zoom-btn" onclick="zoomOut()"><i class="fa-solid fa-minus"></i></button>
                <button class="zoom-btn" onclick="resetView()"><i class="fa-solid fa-rotate-right"></i></button>
            </div>
        </div>

        <div id="bottom-panel">
            <div id="stats-view">
                <div class="stat-card">
                    <div class="stat-val" id="statHeight">0</div>
                    <div class="stat-label">Height</div>
                </div>
                <div class="stat-card">
                    <div class="stat-val" id="statNodes">0</div>
                    <div class="stat-label">Total Nodes</div>
                </div>
                <div class="stat-card">
                    <div class="stat-val" id="statRotations">0</div>
                    <div class="stat-label">Rotations</div>
                </div>
            </div>
        </div>
    </div>

<script>
    const style = getComputedStyle(document.body);
    const COLORS = {
        normal: style.getPropertyValue('--node-normal').trim(),
        compare: style.getPropertyValue('--node-compare').trim(),
        success: style.getPropertyValue('--node-success').trim(),
        imbalance: style.getPropertyValue('--node-imbalance').trim(),
        text: '#ffffff'
    };

    const canvas = document.getElementById('treeCanvas');
    const ctx = canvas.getContext('2d');
    const NODE_RADIUS = 24;

    // --- State ---
    class AVLNode {
        constructor(val) {
            this.val = val;
            this.left = null;
            this.right = null;
            this.height = 1;
            this.x = 0;
            this.y = 0;
            this.parent = null;
        }
    }

    let root = null;
    let animationQueue = [];
    let isAnimating = false;
    let rotationCount = 0;

    // Rotation control state
    let isWaitingForRotation = false;
    let pendingRotationData = null; // Store data for the pending rotation
    let rotationCallback = null;

    // Camera
    let offsetX = 0, offsetY = 0, scale = 1;
    let isDragging = false, dragStartX = 0, dragStartY = 0, lastOffsetX = 0, lastOffsetY = 0;

    // --- Init ---
    function resizeCanvas() {
        const wrapper = document.getElementById('canvas-wrapper');
        canvas.width = wrapper.offsetWidth;
        canvas.height = wrapper.offsetHeight;
        if(!isAnimating) drawTree(null);
    }
    window.addEventListener('resize', resizeCanvas);
    setTimeout(resizeCanvas, 100);

    // --- Camera Controls ---
    canvas.addEventListener('mousedown', e => { isDragging=true; dragStartX=e.clientX; dragStartY=e.clientY; lastOffsetX=offsetX; lastOffsetY=offsetY; canvas.style.cursor='grabbing'; });
    canvas.addEventListener('mousemove', e => { if(isDragging) { offsetX=lastOffsetX+(e.clientX-dragStartX); offsetY=lastOffsetY+(e.clientY-dragStartY); if(!isAnimating) drawTree(null); } });
    canvas.addEventListener('mouseup', () => { isDragging=false; canvas.style.cursor='grab'; });
    canvas.addEventListener('wheel', e => { e.preventDefault(); const s = e.deltaY < 0 ? 1.1 : 0.9; scale = Math.min(Math.max(scale*s, 0.5), 2.5); if(!isAnimating) drawTree(null); });

    // --- Layout Logic ---
    function updatePositions(node, depth=0, x=0, xOffset=240) {
        if(!node) return;
        const y = 80 + depth * 80;
        node.x = x;
        node.y = y;
        updatePositions(node.left, depth+1, x - xOffset, xOffset/1.8);
        updatePositions(node.right, depth+1, x + xOffset, xOffset/1.8);
    }

    function cloneTree(r) {
        if(!r) return null;
        const n = new AVLNode(r.val);
        n.height = r.height;
        n.x = r.x; n.y = r.y;
        n.left = cloneTree(r.left);
        n.right = cloneTree(r.right);
        return n;
    }

    function updateParentPointers(node, parent = null) {
        if (!node) return;
        node.parent = parent;
        updateParentPointers(node.left, node);
        updateParentPointers(node.right, node);
    }

    function findNodeByValue(tree, value) {
        if (!tree) return null;
        if (tree.val === value) return tree;
        const left = findNodeByValue(tree.left, value);
        if (left) return left;
        return findNodeByValue(tree.right, value);
    }

    // --- AVL Logic ---

    function height(n) { return n ? n.height : 0; }
    function getBalance(n) { return n ? height(n.left) - height(n.right) : 0; }
    function updateHeight(n) { n.height = 1 + Math.max(height(n.left), height(n.right)); }

    function rightRotate(y) {
        const x = y.left;
        const T2 = x.right;

        // Rotation
        x.right = y;
        y.left = T2;

        updateHeight(y);
        updateHeight(x);

        return x;
    }

    function leftRotate(x) {
        const y = x.right;
        const T2 = y.left;

        // Rotation
        y.left = x;
        x.right = T2;

        updateHeight(x);
        updateHeight(y);

        return y;
    }

    function countNodes(n) { if(!n) return 0; return 1 + countNodes(n.left) + countNodes(n.right); }

    // --- Rotation Animation Helpers ---

    function showRotateButton(show) {
        document.getElementById('rotation-control').style.display = show ? 'flex' : 'none';
    }

    // UPDATED: Use Lookup Table approach to handle structural changes
    function buildArcPositionMap(beforeTree, afterTree, pivot, rotationType) {
        const map = new Map();
        const beforePositions = new Map();

        // 1. Flatten "Before" Tree
        const collectBefore = (node) => {
            if(!node) return;
            beforePositions.set(node.val, {x: node.x, y: node.y});
            collectBefore(node.left);
            collectBefore(node.right);
        };
        collectBefore(beforeTree);

        // 2. Map "After" Tree
        const mapAfter = (node) => {
            if(!node) return;

            if(beforePositions.has(node.val)) {
                const startPos = beforePositions.get(node.val);
                
                // Calculate distance from pivot
                const distFromPivot = Math.sqrt(
                    (startPos.x - pivot.x) ** 2 +
                    (startPos.y - pivot.y) ** 2
                );

                // Nodes close to the pivot swing in an arc
                const useArc = distFromPivot < 300; 

                map.set(node.val, {
                    startX: startPos.x,
                    startY: startPos.y,
                    endX: node.x,
                    endY: node.y,
                    useArc: useArc,
                    pivot: useArc ? pivot : null
                });
            } else {
                 map.set(node.val, {
                    startX: node.x,
                    startY: node.y,
                    endX: node.x,
                    endY: node.y,
                    useArc: false,
                    pivot: null
                });
            }

            mapAfter(node.left);
            mapAfter(node.right);
        };
        mapAfter(afterTree);

        return map;
    }

    function applyArcInterpolation(node, positionMap, progress) {
        if (!node) return;

        const pos = positionMap.get(node.val);
        if (pos) {
            const ease = t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            const p = ease(progress);

            if (pos.useArc && pos.pivot) {
                // ARC INTERPOLATION
                const start = { x: pos.startX, y: pos.startY };
                const end = { x: pos.endX, y: pos.endY };
                const pivot = pos.pivot;

                const startVec = { x: start.x - pivot.x, y: start.y - pivot.y };
                const endVec = { x: end.x - pivot.x, y: end.y - pivot.y };

                const startAngle = Math.atan2(startVec.y, startVec.x);
                const endAngle = Math.atan2(endVec.y, endVec.x);

                let deltaAngle = endAngle - startAngle;
                if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
                if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
                const currentAngle = startAngle + deltaAngle * p;

                const startRadius = Math.sqrt(startVec.x ** 2 + startVec.y ** 2);
                const endRadius = Math.sqrt(endVec.x ** 2 + endVec.y ** 2);
                const currentRadius = startRadius + (endRadius - startRadius) * p;

                node.x = pivot.x + currentRadius * Math.cos(currentAngle);
                node.y = pivot.y + currentRadius * Math.sin(currentAngle);

            } else {
                // LINEAR INTERPOLATION
                node.x = pos.startX + (pos.endX - pos.startX) * p;
                node.y = pos.startY + (pos.endY - pos.startY) * p;
            }
        }

        applyArcInterpolation(node.left, positionMap, progress);
        applyArcInterpolation(node.right, positionMap, progress);
    }

    function executeRotation() {
        if (!pendingRotationData) return;

        document.getElementById('rotateBtn').disabled = true;
        showRotateButton(false);
        showStatus(`Performing ${pendingRotationData.rotationType} rotation...`);

        const step = pendingRotationData;
        
        const positionMap = buildArcPositionMap(
            step.beforeSnapshot, 
            step.afterSnapshot, 
            step.pivot, 
            step.rotationType
        );

        const duration = 1000;
        const startTime = performance.now();

        const animate = (currentTime) => {
            let progress = (currentTime - startTime) / duration;
            if (progress > 1) progress = 1;

            const interpolated = cloneTree(step.afterSnapshot);
            applyArcInterpolation(interpolated, positionMap, progress);

            drawTree({
                type: 'rotate',
                treeSnapshot: interpolated,
                target: null
            });

            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                rotationCount++;
                if (rotationCallback) rotationCallback();
                pendingRotationData = null;
            }
        };

        requestAnimationFrame(animate);
    }

    // --- Operations ---

    function handleInsert() {
        const val = getVal(); if(val===null) return;
        animationQueue = [];

        const insertBST = (node, v) => {
            if(!node) return new AVLNode(v);
            if(v < node.val) node.left = insertBST(node.left, v);
            else if(v > node.val) node.right = insertBST(node.right, v);
            else return node;
            updateHeight(node);
            return node;
        };

        if(!root) {
            root = new AVLNode(val);
            updateParentPointers(root);
            updatePositions(root);
            animationQueue.push({ type: 'success', treeSnapshot: cloneTree(root), target: root, msg: `Inserted ${val}` });
            runAnimation();
            return;
        }

        root = insertBST(root, val);
        updateParentPointers(root);
        updatePositions(root);

        const findNode = (node, v) => {
            if(!node || node.val === v) return node;
            if(v < node.val) return findNode(node.left, v);
            return findNode(node.right, v);
        };
        const insertedNode = findNode(root, val);
        animationQueue.push({ type: 'success', treeSnapshot: cloneTree(root), target: insertedNode, msg: `Inserted ${val} (BST position)` });

        // Step 2: Rebalance with Parent Patching
        const rebalance = (node, v) => {
            if(!node) return node;

            if(v < node.val) node.left = rebalance(node.left, v);
            else if(v > node.val) node.right = rebalance(node.right, v);

            updateHeight(node);
            const balance = getBalance(node);

            if(balance > 1 || balance < -1) {
                animationQueue.push({ 
                    type: 'imbalance', 
                    treeSnapshot: cloneTree(root), 
                    target: node, 
                    msg: `Imbalance at ${node.val} (BF: ${balance})` 
                });

                // --- Left Left Case ---
                if(balance > 1 && v < node.left.val) {
                    const beforeSnapshot = cloneTree(root);
                    updatePositions(beforeSnapshot);
                    const oldNodeVal = node.val;
                    
                    // Capture parent context
                    const parent = node.parent;
                    const isLeft = parent && parent.left === node;
                    const isRight = parent && parent.right === node;

                    node = rightRotate(node); 
                    
                    // PATCH: Fix global linkage immediately for snapshot
                    if(!parent) root = node;
                    else if(isLeft) parent.left = node;
                    else if(isRight) parent.right = node;
                    
                    updateParentPointers(root); // Safe now
                    updatePositions(root);
                    const afterSnapshot = cloneTree(root);

                    const beforeNode = findNodeByValue(beforeSnapshot, oldNodeVal);
                    if (beforeNode && beforeNode.left) {
                        const pivot = { x: beforeNode.left.x, y: beforeNode.left.y };
                        animationQueue.push({
                            type: 'await-rotation',
                            beforeSnapshot: beforeSnapshot,
                            afterSnapshot: afterSnapshot,
                            pivot: pivot,
                            rotationType: 'Right Rotation',
                            msg: `Right Rotation needed at ${oldNodeVal}`
                        });
                    }
                }
                // --- Right Right Case ---
                else if(balance < -1 && v > node.right.val) {
                    const beforeSnapshot = cloneTree(root);
                    updatePositions(beforeSnapshot);
                    const oldNodeVal = node.val;

                    const parent = node.parent;
                    const isLeft = parent && parent.left === node;
                    const isRight = parent && parent.right === node;

                    node = leftRotate(node);
                    
                    // PATCH
                    if(!parent) root = node;
                    else if(isLeft) parent.left = node;
                    else if(isRight) parent.right = node;

                    updateParentPointers(root);
                    updatePositions(root);
                    const afterSnapshot = cloneTree(root);

                    const beforeNode = findNodeByValue(beforeSnapshot, oldNodeVal);
                    if (beforeNode && beforeNode.right) {
                        const pivot = { x: beforeNode.right.x, y: beforeNode.right.y };
                        animationQueue.push({
                            type: 'await-rotation',
                            beforeSnapshot: beforeSnapshot,
                            afterSnapshot: afterSnapshot,
                            pivot: pivot,
                            rotationType: 'Left Rotation',
                            msg: `Left Rotation needed at ${oldNodeVal}`
                        });
                    }
                }
                // --- Left Right Case ---
                else if(balance > 1 && v > node.left.val) {
                    // Part 1: Left Rotate Child (No global patch needed as root path persists)
                    const beforeSnapshot1 = cloneTree(root);
                    updatePositions(beforeSnapshot1);
                    const oldLeftVal = node.left.val;

                    node.left = leftRotate(node.left);
                    updateParentPointers(root);
                    updatePositions(root);
                    const afterSnapshot1 = cloneTree(root);

                    const beforeNode1 = findNodeByValue(beforeSnapshot1, oldLeftVal);
                    if(beforeNode1 && beforeNode1.right) {
                        animationQueue.push({
                            type: 'await-rotation',
                            beforeSnapshot: beforeSnapshot1,
                            afterSnapshot: afterSnapshot1,
                            pivot: { x: beforeNode1.right.x, y: beforeNode1.right.y },
                            rotationType: 'Left (Child)',
                            msg: `Step 1: Left Rotate Child ${oldLeftVal}`
                        });
                    }

                    // Part 2: Right Rotate Root (Needs Patch)
                    const beforeSnapshot2 = cloneTree(root);
                    updatePositions(beforeSnapshot2);
                    const oldNodeVal = node.val;

                    const parent = node.parent;
                    const isLeft = parent && parent.left === node;
                    const isRight = parent && parent.right === node;

                    node = rightRotate(node);

                    // PATCH
                    if(!parent) root = node;
                    else if(isLeft) parent.left = node;
                    else if(isRight) parent.right = node;

                    updateParentPointers(root);
                    updatePositions(root);
                    const afterSnapshot2 = cloneTree(root);

                    const beforeNode2 = findNodeByValue(beforeSnapshot2, oldNodeVal);
                    if(beforeNode2 && beforeNode2.left) {
                         animationQueue.push({
                            type: 'await-rotation',
                            beforeSnapshot: beforeSnapshot2,
                            afterSnapshot: afterSnapshot2,
                            pivot: { x: beforeNode2.left.x, y: beforeNode2.left.y },
                            rotationType: 'Right (Root)',
                            msg: `Step 2: Right Rotate Root ${oldNodeVal}`
                        });
                    }
                }
                // --- Right Left Case ---
                else if(balance < -1 && v < node.right.val) {
                    // Part 1: Right Rotate Child
                    const beforeSnapshot1 = cloneTree(root);
                    updatePositions(beforeSnapshot1);
                    const oldRightVal = node.right.val;

                    node.right = rightRotate(node.right);
                    updateParentPointers(root);
                    updatePositions(root);
                    const afterSnapshot1 = cloneTree(root);

                    const beforeNode1 = findNodeByValue(beforeSnapshot1, oldRightVal);
                    if(beforeNode1 && beforeNode1.left) {
                        animationQueue.push({
                            type: 'await-rotation',
                            beforeSnapshot: beforeSnapshot1,
                            afterSnapshot: afterSnapshot1,
                            pivot: { x: beforeNode1.left.x, y: beforeNode1.left.y },
                            rotationType: 'Right (Child)',
                            msg: `Step 1: Right Rotate Child ${oldRightVal}`
                        });
                    }

                    // Part 2: Left Rotate Root (Needs Patch)
                    const beforeSnapshot2 = cloneTree(root);
                    updatePositions(beforeSnapshot2);
                    const oldNodeVal = node.val;

                    const parent = node.parent;
                    const isLeft = parent && parent.left === node;
                    const isRight = parent && parent.right === node;

                    node = leftRotate(node);

                    // PATCH
                    if(!parent) root = node;
                    else if(isLeft) parent.left = node;
                    else if(isRight) parent.right = node;

                    updateParentPointers(root);
                    updatePositions(root);
                    const afterSnapshot2 = cloneTree(root);

                    const beforeNode2 = findNodeByValue(beforeSnapshot2, oldNodeVal);
                    if(beforeNode2 && beforeNode2.right) {
                        animationQueue.push({
                            type: 'await-rotation',
                            beforeSnapshot: beforeSnapshot2,
                            afterSnapshot: afterSnapshot2,
                            pivot: { x: beforeNode2.right.x, y: beforeNode2.right.y },
                            rotationType: 'Left (Root)',
                            msg: `Step 2: Left Rotate Root ${oldNodeVal}`
                        });
                    }
                }
            }

            return node;
        };

        root = rebalance(root, val);
        updatePositions(root);

        if(animationQueue.length === 1) {
            animationQueue.push({ type: 'idle', treeSnapshot: cloneTree(root), msg: 'Tree is balanced' });
        }

        runAnimation();
    }

    function handleFind() {
        const val = getVal(); if(val===null) return;
        animationQueue = [];
        let curr = root;
        while(curr) {
            animationQueue.push({ type: 'compare', treeSnapshot: cloneTree(root), target: curr });
            if(val === curr.val) {
                animationQueue.push({ type: 'success', treeSnapshot: cloneTree(root), target: curr, msg: "Found!" });
                runAnimation();
                return;
            }
            if(val < curr.val) curr = curr.left;
            else curr = curr.right;
        }
        showStatus("Value not found");
        runAnimation();
    }

    function handleDelete() {
        const val = getVal(); if(val===null) return;
        animationQueue = [];

        const deleteRec = (node, v) => {
            if(!node) return node;

            animationQueue.push({ type: 'compare', treeSnapshot: cloneTree(root), target: node });

            if(v < node.val) node.left = deleteRec(node.left, v);
            else if(v > node.val) node.right = deleteRec(node.right, v);
            else {
                if((!node.left) || (!node.right)) {
                    let temp = node.left ? node.left : node.right;
                    if(!temp) { node = null; } 
                    else { node = temp; } 
                } else {
                    let temp = node.right;
                    while(temp.left) temp = temp.left;
                    node.val = temp.val;
                    node.right = deleteRec(node.right, temp.val);
                }
            }

            if(!node) return node;

            updateHeight(node);
            const balance = getBalance(node);

            if(balance > 1 || balance < -1) {
                animationQueue.push({ type: 'imbalance', treeSnapshot: cloneTree(root), target: node, msg: `Imbalance at ${node.val}` });
            }

            // Simple delete rotation (no fancy animation yet)
            if(balance > 1 && getBalance(node.left) >= 0) return rightRotate(node);
            if(balance > 1 && getBalance(node.left) < 0) {
                node.left = leftRotate(node.left);
                return rightRotate(node);
            }
            if(balance < -1 && getBalance(node.right) <= 0) return leftRotate(node);
            if(balance < -1 && getBalance(node.right) > 0) {
                node.right = rightRotate(node.right);
                return leftRotate(node);
            }

            return node;
        };

        const oldRoot = cloneTree(root);
        root = deleteRec(root, val);
        updatePositions(root);
        
        if(root || oldRoot) {
             animationQueue.push({ type: 'idle', treeSnapshot: cloneTree(root), msg: "Deletion Complete" });
             runAnimation();
        }
    }

    // --- Animation Engine ---
    function runAnimation() {
        if(isAnimating || animationQueue.length === 0) return;
        isAnimating = true;
        disableControls(true);
        let stepIndex = 0;
        
        const process = () => {
            if(stepIndex >= animationQueue.length) {
                isAnimating = false;
                disableControls(false);
                updateStats();
                drawTree(null);
                return;
            }
            const step = animationQueue[stepIndex++];
            if(step.msg) showStatus(step.msg);

            if(step.type === 'await-rotation') {
                pendingRotationData = step;
                isWaitingForRotation = true;
                showRotateButton(true);
                document.getElementById('rotateBtn').disabled = false;
                
                drawTree({
                    treeSnapshot: step.beforeSnapshot,
                    target: null 
                });

                rotationCallback = () => {
                    showRotateButton(false);
                    isWaitingForRotation = false;
                    setTimeout(process, 100);
                };
                return;
            }

            drawTree(step);

            let delay = 500;
            if(step.type === 'rotate') delay = 1000;
            if(step.type === 'imbalance') delay = 900;
            if(step.type === 'success') delay = 600;
            if(step.type === 'compare') delay = 200;

            setTimeout(process, delay);
        };
        process();
    }

    // --- Drawing ---
    function drawTree(step) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const centerX = canvas.width / 2;
        const data = step ? step.treeSnapshot : root;
        if(!data) return;

        ctx.save();
        ctx.translate(-offsetX, offsetY); 
        ctx.translate(canvas.width/2 + offsetX, 50 + offsetY);
        ctx.scale(scale, scale);
        
        ctx.translate(-data.x, 0);

        const drawEdges = (node) => {
            if(!node) return;
            if(node.left) {
                ctx.beginPath(); ctx.moveTo(node.x, node.y); ctx.lineTo(node.left.x, node.left.y);
                ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 2; ctx.stroke();
                drawEdges(node.left);
            }
            if(node.right) {
                ctx.beginPath(); ctx.moveTo(node.x, node.y); ctx.lineTo(node.right.x, node.right.y);
                ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 2; ctx.stroke();
                drawEdges(node.right);
            }
        };
        drawEdges(data);

        const drawNodes = (node) => {
            if(!node) return;
            
            let color = COLORS.normal;
            if(step && step.target && node.x === step.target.x && node.y === step.target.y) {
                 if(step.type === 'compare') color = COLORS.compare;
                 if(step.type === 'success' || step.type === 'spawn') color = COLORS.success;
                 if(step.type === 'imbalance' || step.type === 'rotate') color = COLORS.imbalance;
            }

            ctx.beginPath();
            ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI*2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.8)'; ctx.lineWidth = 2; ctx.stroke();

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Inter';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(node.val, node.x, node.y);

            const bf = height(node.left) - height(node.right);
            ctx.fillStyle = (bf > 1 || bf < -1) ? '#ff6b6b' : '#94a3b8';
            ctx.font = '11px Inter';
            ctx.textAlign = 'left';
            ctx.fillText(`BF:${bf}`, node.x + 28, node.y - 5);
            ctx.fillStyle = '#94a3b8';
            ctx.fillText(`H:${node.height}`, node.x + 28, node.y + 8);

            drawNodes(node.left);
            drawNodes(node.right);
        };
        drawNodes(data);

        ctx.restore();
    }

    // --- Helpers ---
    function getVal() {
        const el = document.getElementById('valInput');
        if(!el.value) { el.focus(); return null; }
        const v = parseInt(el.value);
        el.value = ''; el.focus();
        return isNaN(v) ? null : v;
    }

    function showStatus(msg) {
        const el = document.getElementById('statusMessage');
        el.innerText = msg; el.classList.add('show');
        setTimeout(()=>el.classList.remove('show'), 2000);
    }
    
    function updateStats() {
        if(!root) {
            document.getElementById('statHeight').innerText = '0';
            document.getElementById('statNodes').innerText = '0';
        } else {
            document.getElementById('statHeight').innerText = height(root);
            document.getElementById('statNodes').innerText = countNodes(root);
        }
        document.getElementById('statRotations').innerText = rotationCount;
    }
    
    function handleRandom() {
        handleClear();
        const vals = Array.from({length: 8}, () => Math.floor(Math.random()*99)+1);
        vals.forEach(v => {
            if(!root) root = new AVLNode(v);
            else {
                const insertRec = (node, val) => {
                    if(!node) return new AVLNode(val);
                    if(val < node.val) node.left = insertRec(node.left, val);
                    else if(val > node.val) node.right = insertRec(node.right, val);
                    else return node;
                    updateHeight(node);
                    let balance = getBalance(node);
                    if(balance > 1 && val < node.left.val) return rightRotate(node);
                    if(balance < -1 && val > node.right.val) return leftRotate(node);
                    if(balance > 1 && val > node.left.val) { node.left = leftRotate(node.left); return rightRotate(node); }
                    if(balance < -1 && val < node.right.val) { node.right = rightRotate(node.right); return leftRotate(node); }
                    return node;
                };
                root = insertRec(root, v);
            }
        });
        updatePositions(root);
        updateStats();
        drawTree(null);
        showStatus("Random Tree Generated");
    }
    
    function handleClear() {
        root = null;
        animationQueue = [];
        rotationCount = 0;
        isAnimating = false;
        isWaitingForRotation = false;
        pendingRotationData = null;
        rotationCallback = null;
        showRotateButton(false);
        updateStats();
        drawTree(null);
        showStatus("Cleared");
    }
    
    function handleEnter(e) { if(e.key==='Enter') handleInsert(); }
    
    function disableControls(dis) {
        document.querySelectorAll('button:not(.zoom-btn)').forEach(b=>b.disabled=dis);
    }

    function zoomIn() { scale = Math.min(scale*1.2, 2.5); drawTree(null); }
    function zoomOut() { scale = Math.max(scale/1.2, 0.5); drawTree(null); }
    function resetView() { offsetX=0; offsetY=0; scale=1; drawTree(null); }

    resizeCanvas();
    updateStats();
    showStatus("Ready");

    // --- Disclaimer Modal ---
    function closeDisclaimer() {
        const modal = document.getElementById('disclaimerModal');
        modal.classList.add('hidden');
        setTimeout(() => {
            modal.style.display = 'none';
        }, 300);
    }

</script>
</body>
</html>