<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AVL Tree - gsu dsa</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    <style>
        :root {
            --gsu-blue: #0039A6;
            --gsu-blue-light: #4d8dff;
            --text-main: #ffffff;
            --text-muted: #94a3b8;
            --glass-bg: rgba(15, 23, 42, 0.65);
            --glass-border: rgba(255, 255, 255, 0.15);
            
            /* Node Colors */
            --node-normal: #0039A6;
            --node-compare: #ffc107;
            --node-success: #28a745;
            --node-imbalance: #ff4757; /* Red for imbalance */
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #000c24;
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        /* --- BACKGROUND AURA --- */
        .aura-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            filter: blur(80px);
            opacity: 0.6;
            pointer-events: none;
        }
        .aura-blob {
            position: absolute;
            border-radius: 50%;
            mix-blend-mode: screen;
            animation: float 20s infinite ease-in-out alternate;
        }
        .blob-1 { background: var(--gsu-blue); width: 700px; height: 700px; top: -10%; left: -10%; animation-duration: 25s; }
        .blob-2 { background: #0055CC; width: 600px; height: 600px; bottom: -10%; right: -20%; animation-delay: -5s; animation-duration: 30s; }
        .blob-3 { background: #001F5C; width: 800px; height: 800px; bottom: -20%; left: 20%; opacity: 0.8; animation-delay: -10s; }
        @keyframes float {
            0% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(50px, 50px) scale(1.1); }
            100% { transform: translate(-30px, -20px) scale(0.9); }
        }

        /* --- MAIN GLASS CONTAINER --- */
        .main-glass-card {
            width: 100%;
            max-width: 1600px;
            height: 95vh;
            background: var(--glass-bg);
            backdrop-filter: blur(40px) saturate(180%);
            -webkit-backdrop-filter: blur(40px) saturate(180%);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 40px 80px -20px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        /* --- HEADER & CONTROLS --- */
        header {
            padding: 20px 30px;
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(255, 255, 255, 0.03);
            z-index: 20;
        }

        .header-left { display: flex; align-items: center; gap: 20px; }
        
        h1 {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-main);
            letter-spacing: -0.5px;
        }

        .back-btn {
            color: var(--gsu-blue-light);
            text-decoration: none;
            font-weight: 500;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            border: 1px solid var(--glass-border);
            transition: all 0.2s;
        }
        .back-btn:hover { background: rgba(255,255,255,0.1); border-color: var(--text-muted); }

        .controls-toolbar {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            gap: 8px;
            align-items: center;
            padding-left: 12px;
            border-left: 1px solid var(--glass-border);
        }
        .control-group:first-child { border-left: none; padding-left: 0; }

        input[type="number"] {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            color: white;
            padding: 10px 14px;
            border-radius: 10px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            width: 90px;
            outline: none;
            transition: border-color 0.2s;
        }
        input:focus { border-color: var(--gsu-blue-light); }

        button {
            background: rgba(255,255,255,0.08);
            color: white;
            border: 1px solid var(--glass-border);
            padding: 10px 18px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 500;
            font-size: 13px;
            font-family: 'Inter', sans-serif;
            transition: all 0.2s;
        }
        button:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-1px);
        }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        button.primary { background: var(--gsu-blue); border-color: var(--gsu-blue); }
        button.primary:hover { background: #004BC9; }

        button.danger {
            background: rgba(204, 0, 0, 0.2);
            border-color: rgba(204, 0, 0, 0.4);
            color: #ff6b6b;
        }
        button.danger:hover { background: rgba(204, 0, 0, 0.3); border-color: #ff6b6b; }

        /* Rotation Control */
        #rotation-control {
            animation: pulseGlow 1.5s ease-in-out infinite;
        }

        @keyframes pulseGlow {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.85; transform: scale(1.05); }
        }

        #rotateBtn {
            background: linear-gradient(135deg, var(--gsu-blue), #0055CC);
            border-color: var(--gsu-blue);
            box-shadow: 0 4px 15px rgba(0, 57, 166, 0.4);
            font-weight: 600;
        }

        #rotateBtn:hover {
            background: linear-gradient(135deg, #004BC9, #0066DD);
            box-shadow: 0 6px 20px rgba(0, 57, 166, 0.6);
        }

        /* --- CANVAS AREA --- */
        #canvas-wrapper {
            flex-grow: 1;
            position: relative;
            background: rgba(0,0,0,0.2);
            overflow: hidden;
            cursor: grab;
            z-index: 1;
        }
        #canvas-wrapper:active { cursor: grabbing; }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .zoom-btn {
            width: 40px; height: 40px; padding: 0;
            display: flex; align-items: center; justify-content: center;
            font-size: 18px;
            background: rgba(15, 23, 42, 0.8);
            border-color: var(--glass-border);
            border-radius: 10px;
        }
        .zoom-btn:hover { background: rgba(255,255,255,0.1); }

        .legend {
            position: absolute;
            top: 20px; left: 20px;
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(10px);
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 12px;
            color: var(--text-muted);
            pointer-events: none;
        }
        .legend-item { display: flex; align-items: center; gap: 8px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; box-shadow: 0 0 8px currentColor; }

        .status-message {
            position: absolute;
            top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid var(--gsu-blue-light);
            color: var(--gsu-blue-light);
            padding: 10px 24px; border-radius: 20px;
            font-size: 14px; pointer-events: none;
            opacity: 0; transition: opacity 0.3s;
            z-index: 1000; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .status-message.show { opacity: 1; }

        /* --- BOTTOM PANEL (Traversal / Stats) --- */
        #bottom-panel {
            height: 140px;
            min-height: 140px;
            border-top: 1px solid var(--glass-border);
            background: rgba(0,0,0,0.2);
            padding: 10px 30px;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* Stats View */
        #stats-view {
            display: flex;
            height: 100%;
            justify-content: center;
            align-items: center;
            gap: 40px;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 15px 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 120px;
        }
        .stat-val {
            font-size: 24px;
            font-weight: 700;
            color: white;
            margin-bottom: 4px;
        }
        .stat-label {
            font-size: 12px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

    </style>
</head>
<body>

    <div class="aura-container">
        <div class="aura-blob blob-1"></div>
        <div class="aura-blob blob-2"></div>
        <div class="aura-blob blob-3"></div>
    </div>

    <div class="main-glass-card">
        <header>
            <div class="header-left">
                <a href="#" class="back-btn" onclick="window.parent.closeIframe(); return false;">‚Üê Back</a>
                <h1><i class="fa-solid fa-scale-balanced" style="margin-right: 12px; color: var(--gsu-blue-light);"></i>AVL Tree</h1>
            </div>
            
            <div class="controls-toolbar">
                <div class="control-group">
                    <input type="number" id="valInput" placeholder="Value" onkeypress="handleEnter(event)">
                    <button class="primary" onclick="handleInsert()">Insert</button>
                    <button class="danger" onclick="handleDelete()">Delete</button>
                    <button onclick="handleFind()">Find</button>
                </div>

                <div class="control-group">
                    <button onclick="handleRandom()">Random</button>
                    <button onclick="handleClear()">Clear</button>
                </div>

                <div class="control-group" id="rotation-control" style="display: none;">
                    <button class="primary" id="rotateBtn" onclick="executeRotation()">Rotate</button>
                </div>
            </div>
        </header>

        <div id="canvas-wrapper">
            <canvas id="treeCanvas"></canvas>

            <div class="status-message" id="statusMessage"></div>

            <div class="legend">
                <div class="legend-item"><div class="dot" style="color: var(--node-normal); background: currentColor;"></div>Balanced</div>
                <div class="legend-item"><div class="dot" style="color: var(--node-imbalance); background: currentColor;"></div>Rotating/Imbalanced</div>
                <div class="legend-item"><div class="dot" style="color: var(--node-success); background: currentColor;"></div>Inserted/Success</div>
            </div>

            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomIn()"><i class="fa-solid fa-plus"></i></button>
                <button class="zoom-btn" onclick="zoomOut()"><i class="fa-solid fa-minus"></i></button>
                <button class="zoom-btn" onclick="resetView()"><i class="fa-solid fa-rotate-right"></i></button>
            </div>
        </div>

        <div id="bottom-panel">
            <div id="stats-view">
                <div class="stat-card">
                    <div class="stat-val" id="statHeight">0</div>
                    <div class="stat-label">Height</div>
                </div>
                <div class="stat-card">
                    <div class="stat-val" id="statNodes">0</div>
                    <div class="stat-label">Total Nodes</div>
                </div>
                <div class="stat-card">
                    <div class="stat-val" id="statRotations">0</div>
                    <div class="stat-label">Rotations</div>
                </div>
            </div>
        </div>
    </div>

<script>
    const style = getComputedStyle(document.body);
    const COLORS = {
        normal: style.getPropertyValue('--node-normal').trim(),
        compare: style.getPropertyValue('--node-compare').trim(),
        success: style.getPropertyValue('--node-success').trim(),
        imbalance: style.getPropertyValue('--node-imbalance').trim(),
        text: '#ffffff'
    };

    const canvas = document.getElementById('treeCanvas');
    const ctx = canvas.getContext('2d');
    const NODE_RADIUS = 24;

    // --- State ---
    class AVLNode {
        constructor(val) {
            this.val = val;
            this.left = null;
            this.right = null;
            this.height = 1;
            this.x = 0;
            this.y = 0;
        }
    }

    let root = null;
    let animationQueue = [];
    let isAnimating = false;
    let rotationCount = 0;

    // Rotation control state
    let isWaitingForRotation = false;
    let pendingRotationType = null; // 'LL', 'RR', 'LR', 'RL'
    let skipRootRotation = false;
    let rotationCallback = null;

    // Camera
    let offsetX = 0, offsetY = 0, scale = 1;
    let isDragging = false, dragStartX = 0, dragStartY = 0, lastOffsetX = 0, lastOffsetY = 0;

    // --- Init ---
    function resizeCanvas() {
        const wrapper = document.getElementById('canvas-wrapper');
        canvas.width = wrapper.offsetWidth;
        canvas.height = wrapper.offsetHeight;
        if(!isAnimating) drawTree(null);
    }
    window.addEventListener('resize', resizeCanvas);
    setTimeout(resizeCanvas, 100);

    // --- Camera Controls ---
    canvas.addEventListener('mousedown', e => { isDragging=true; dragStartX=e.clientX; dragStartY=e.clientY; lastOffsetX=offsetX; lastOffsetY=offsetY; canvas.style.cursor='grabbing'; });
    canvas.addEventListener('mousemove', e => { if(isDragging) { offsetX=lastOffsetX+(e.clientX-dragStartX); offsetY=lastOffsetY+(e.clientY-dragStartY); if(!isAnimating) drawTree(null); } });
    canvas.addEventListener('mouseup', () => { isDragging=false; canvas.style.cursor='grab'; });
    canvas.addEventListener('wheel', e => { e.preventDefault(); const s = e.deltaY < 0 ? 1.1 : 0.9; scale = Math.min(Math.max(scale*s, 0.5), 2.5); if(!isAnimating) drawTree(null); });

    // --- Layout Logic ---
    function updatePositions(node, depth=0, x=0, xOffset=240) {
        if(!node) return;
        const y = 80 + depth * 80;
        node.x = x;
        node.y = y;
        updatePositions(node.left, depth+1, x - xOffset, xOffset/1.8);
        updatePositions(node.right, depth+1, x + xOffset, xOffset/1.8);
    }

    function cloneTree(r) {
        if(!r) return null;
        const n = new AVLNode(r.val);
        n.height = r.height;
        n.x = r.x; n.y = r.y;
        n.left = cloneTree(r.left);
        n.right = cloneTree(r.right);
        return n;
    }

    // --- AVL Logic ---

    function height(n) { return n ? n.height : 0; }
    function getBalance(n) { return n ? height(n.left) - height(n.right) : 0; }
    function updateHeight(n) { n.height = 1 + Math.max(height(n.left), height(n.right)); }

    function rightRotate(y) {
        const x = y.left;
        const T2 = x.right;
        
        // Rotation
        x.right = y;
        y.left = T2;
        
        updateHeight(y);
        updateHeight(x);
        
        rotationCount++;
        return x;
    }

    function leftRotate(x) {
        const y = x.right;
        const T2 = y.left;
        
        // Rotation
        y.left = x;
        x.right = T2;
        
        updateHeight(x);
        updateHeight(y);
        
        rotationCount++;
        return y;
    }

    function countNodes(n) { if(!n) return 0; return 1 + countNodes(n.left) + countNodes(n.right); }

    // --- Rotation Animation Helpers ---

    function showRotateButton(show) {
        document.getElementById('rotation-control').style.display = show ? 'flex' : 'none';
    }

    function buildPositionMap(beforeTree, afterTree) {
        const map = new Map();

        const traverse = (before, after) => {
            if (!before || !after) return;

            // Map node value to before/after positions
            map.set(after.val, {
                startX: before.x,
                startY: before.y,
                endX: after.x,
                endY: after.y
            });

            // Recursively map children
            if (before.left && after.left) traverse(before.left, after.left);
            if (before.right && after.right) traverse(before.right, after.right);

            // Handle restructured nodes (left child becomes parent, etc.)
            if (before.left && after.right && before.left.val === after.right.val) {
                traverse(before.left, after.right);
            }
            if (before.right && after.left && before.right.val === after.left.val) {
                traverse(before.right, after.left);
            }
        };

        traverse(beforeTree, afterTree);
        return map;
    }

    function applyInterpolation(node, positionMap, progress) {
        if (!node) return;

        const pos = positionMap.get(node.val);
        if (pos) {
            // Ease-in-out quad easing
            const ease = t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            const p = ease(progress);

            node.x = pos.startX + (pos.endX - pos.startX) * p;
            node.y = pos.startY + (pos.endY - pos.startY) * p;
        }

        applyInterpolation(node.left, positionMap, progress);
        applyInterpolation(node.right, positionMap, progress);
    }

    function animateRotation(rotationType, callback) {
        // 1. Capture "before" positions
        const beforeSnapshot = cloneTree(root);
        updatePositions(beforeSnapshot);

        // 2. Perform rotation(s)
        switch(rotationType) {
            case 'LL':
                root = rightRotate(root);
                break;
            case 'RR':
                root = leftRotate(root);
                break;
            case 'LR':
                root.left = leftRotate(root.left);
                root = rightRotate(root);
                break;
            case 'RL':
                root.right = rightRotate(root.right);
                root = leftRotate(root);
                break;
        }

        // 3. Calculate "after" positions
        updatePositions(root);
        const afterSnapshot = cloneTree(root);

        // 4. Build position map
        const positionMap = buildPositionMap(beforeSnapshot, afterSnapshot);

        // 5. Animate with requestAnimationFrame
        const duration = 800; // ms
        const startTime = performance.now();

        const animate = (currentTime) => {
            let progress = (currentTime - startTime) / duration;
            if (progress > 1) progress = 1;

            // Create interpolated snapshot
            const interpolated = cloneTree(root);
            applyInterpolation(interpolated, positionMap, progress);

            // Draw interpolated state
            drawTree({
                type: 'rotate',
                treeSnapshot: interpolated,
                target: root
            });

            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete
                callback();
            }
        };

        requestAnimationFrame(animate);
    }

    function executeRotation() {
        if (!pendingRotationType) return;

        // Disable button immediately to prevent double-clicks
        document.getElementById('rotateBtn').disabled = true;

        // Hide button and update message
        showRotateButton(false);
        showStatus(`Performing ${pendingRotationType} rotation...`);

        // Execute smooth rotation
        animateRotation(pendingRotationType, () => {
            // After animation completes
            updateStats();
            isWaitingForRotation = false;
            pendingRotationType = null;
            skipRootRotation = false;

            // Resume animation queue if there's a callback
            if (rotationCallback) {
                const cb = rotationCallback;
                rotationCallback = null;
                cb();
            }
        });
    }

    // --- Operations ---

    function handleInsert() {
        const val = getVal(); if(val===null) return;
        animationQueue = [];

        // Step 1: Perform BST insertion without rotation
        const insertBST = (node, v) => {
            if(!node) return new AVLNode(v);
            if(v < node.val) node.left = insertBST(node.left, v);
            else if(v > node.val) node.right = insertBST(node.right, v);
            else return node; // No duplicates
            updateHeight(node);
            return node;
        };

        // If root is null, special case
        if(!root) {
            root = new AVLNode(val);
            updatePositions(root);
            animationQueue.push({ type: 'success', treeSnapshot: cloneTree(root), target: root, msg: `Inserted ${val}` });
            runAnimation();
            return;
        }

        // Perform BST insertion first
        root = insertBST(root, val);
        updatePositions(root);

        // Show the inserted node in BST position (before any rotation)
        const findNode = (node, v) => {
            if(!node || node.val === v) return node;
            if(v < node.val) return findNode(node.left, v);
            return findNode(node.right, v);
        };
        const insertedNode = findNode(root, val);
        animationQueue.push({ type: 'success', treeSnapshot: cloneTree(root), target: insertedNode, msg: `Inserted ${val} (BST position)` });

        // CHECK: Does root need rotation?
        const rootBalance = getBalance(root);
        if (Math.abs(rootBalance) > 1) {
            // Determine rotation type
            let rotationType = null;

            if (rootBalance > 1 && val < root.left.val) {
                rotationType = 'LL';
            } else if (rootBalance < -1 && val > root.right.val) {
                rotationType = 'RR';
            } else if (rootBalance > 1 && val > root.left.val) {
                rotationType = 'LR';
            } else if (rootBalance < -1 && val < root.right.val) {
                rotationType = 'RL';
            }

            if (rotationType) {
                // Root needs rotation - pause for user input
                pendingRotationType = rotationType;
                skipRootRotation = true;

                // Push imbalance detection to queue
                animationQueue.push({
                    type: 'imbalance',
                    treeSnapshot: cloneTree(root),
                    target: root,
                    msg: `Imbalance at root (BF: ${rootBalance})`
                });

                // Push pause step
                animationQueue.push({
                    type: 'await-rotation',
                    treeSnapshot: cloneTree(root),
                    msg: 'Rotation available.'
                });

                // Skip the rebalance call and just run animation
                runAnimation();
                return;
            }
        }

        // Step 2: Now perform rebalancing with rotations
        const rebalance = (node, v, isRoot = false) => {
            if(!node) return node;

            // Recursively rebalance children first
            if(v < node.val) node.left = rebalance(node.left, v, false);
            else if(v > node.val) node.right = rebalance(node.right, v, false);

            updateHeight(node);
            const balance = getBalance(node);

            // Check if unbalanced
            if(balance > 1 || balance < -1) {
                // If this is root AND we're waiting for user to click button, skip rotation
                if(isRoot && skipRootRotation) {
                    return node; // Don't rotate, user will trigger it
                }

                animationQueue.push({ type: 'imbalance', treeSnapshot: cloneTree(root), target: node, msg: `Imbalance at ${node.val} (BF: ${balance})` });

                // Left Left Case
                if(balance > 1 && v < node.left.val) {
                    animationQueue.push({ type: 'rotate', treeSnapshot: cloneTree(root), target: node, msg: `Right rotation at ${node.val}` });
                    node = rightRotate(node);
                    updatePositions(root);
                    animationQueue.push({ type: 'success', treeSnapshot: cloneTree(root), msg: 'Rotation complete' });
                }
                // Right Right Case
                else if(balance < -1 && v > node.right.val) {
                    animationQueue.push({ type: 'rotate', treeSnapshot: cloneTree(root), target: node, msg: `Left rotation at ${node.val}` });
                    node = leftRotate(node);
                    updatePositions(root);
                    animationQueue.push({ type: 'success', treeSnapshot: cloneTree(root), msg: 'Rotation complete' });
                }
                // Left Right Case
                else if(balance > 1 && v > node.left.val) {
                    animationQueue.push({ type: 'rotate', treeSnapshot: cloneTree(root), target: node.left, msg: `Left-Right: Left rotation at ${node.left.val}` });
                    node.left = leftRotate(node.left);
                    updatePositions(root);
                    animationQueue.push({ type: 'imbalance', treeSnapshot: cloneTree(root), target: node, msg: `Right rotation at ${node.val}` });
                    node = rightRotate(node);
                    updatePositions(root);
                    animationQueue.push({ type: 'success', treeSnapshot: cloneTree(root), msg: 'Double rotation complete' });
                }
                // Right Left Case
                else if(balance < -1 && v < node.right.val) {
                    animationQueue.push({ type: 'rotate', treeSnapshot: cloneTree(root), target: node.right, msg: `Right-Left: Right rotation at ${node.right.val}` });
                    node.right = rightRotate(node.right);
                    updatePositions(root);
                    animationQueue.push({ type: 'imbalance', treeSnapshot: cloneTree(root), target: node, msg: `Left rotation at ${node.val}` });
                    node = leftRotate(node);
                    updatePositions(root);
                    animationQueue.push({ type: 'success', treeSnapshot: cloneTree(root), msg: 'Double rotation complete' });
                }
            }

            return node;
        };

        root = rebalance(root, val, true);
        updatePositions(root);

        // Final balanced state
        if(animationQueue.length === 1) {
            // No rotations needed, just show success
            animationQueue.push({ type: 'idle', treeSnapshot: cloneTree(root), msg: 'Tree is balanced' });
        }

        runAnimation();
    }

    function handleFind() {
        const val = getVal(); if(val===null) return;
        animationQueue = [];
        let curr = root;
        while(curr) {
            animationQueue.push({ type: 'compare', treeSnapshot: cloneTree(root), target: curr });
            if(val === curr.val) {
                animationQueue.push({ type: 'success', treeSnapshot: cloneTree(root), target: curr, msg: "Found!" });
                runAnimation();
                return;
            }
            if(val < curr.val) curr = curr.left;
            else curr = curr.right;
        }
        showStatus("Value not found");
        runAnimation();
    }

    function handleDelete() {
        const val = getVal(); if(val===null) return;
        animationQueue = [];

        const deleteRec = (node, v) => {
            if(!node) return node;

            animationQueue.push({ type: 'compare', treeSnapshot: cloneTree(root), target: node });

            if(v < node.val) node.left = deleteRec(node.left, v);
            else if(v > node.val) node.right = deleteRec(node.right, v);
            else {
                // Node found
                if((!node.left) || (!node.right)) {
                    let temp = node.left ? node.left : node.right;
                    if(!temp) { node = null; } // No child case
                    else { node = temp; } // One child case
                } else {
                    // Two child case: get inorder successor
                    let temp = node.right;
                    while(temp.left) temp = temp.left;
                    node.val = temp.val;
                    node.right = deleteRec(node.right, temp.val);
                }
            }

            if(!node) return node;

            updateHeight(node);
            const balance = getBalance(node);

            if(balance > 1 || balance < -1) {
                animationQueue.push({ type: 'imbalance', treeSnapshot: cloneTree(root), target: node, msg: `Imbalance at ${node.val}` });
            }

            // LL
            if(balance > 1 && getBalance(node.left) >= 0) return rightRotate(node);
            // LR
            if(balance > 1 && getBalance(node.left) < 0) {
                node.left = leftRotate(node.left);
                return rightRotate(node);
            }
            // RR
            if(balance < -1 && getBalance(node.right) <= 0) return leftRotate(node);
            // RL
            if(balance < -1 && getBalance(node.right) > 0) {
                node.right = rightRotate(node.right);
                return leftRotate(node);
            }

            return node;
        };

        const oldRoot = cloneTree(root);
        root = deleteRec(root, val);
        updatePositions(root);
        
        if(root || oldRoot) {
             animationQueue.push({ type: 'idle', treeSnapshot: cloneTree(root), msg: "Deletion Complete" });
             runAnimation();
        }
    }


    // --- Animation Engine ---
    function runAnimation() {
        if(isAnimating || animationQueue.length === 0) return;
        isAnimating = true;
        disableControls(true);
        let stepIndex = 0;
        
        const process = () => {
            if(stepIndex >= animationQueue.length) {
                isAnimating = false;
                disableControls(false);
                updateStats();
                drawTree(null);
                return;
            }
            const step = animationQueue[stepIndex++];
            if(step.msg) showStatus(step.msg);

            // Handle rotation pause
            if(step.type === 'await-rotation') {
                isWaitingForRotation = true;
                showRotateButton(true);
                // Enable the Rotate button (it was disabled by disableControls)
                document.getElementById('rotateBtn').disabled = false;
                drawTree(step);

                // Store callback to resume animation
                rotationCallback = () => {
                    showRotateButton(false);
                    isWaitingForRotation = false;

                    // Final success message
                    showStatus('Tree is balanced');
                    setTimeout(() => {
                        isAnimating = false;
                        disableControls(false);
                        updateStats();
                        drawTree(null);
                    }, 600);
                };

                // Don't call process() again - wait for button click
                return;
            }

            drawTree(step);

            // Adjust speed: emphasize rotations (concept-focused)
            let delay = 500;
            if(step.type === 'rotate') delay = 1000;  // Slow down rotations to highlight them
            if(step.type === 'imbalance') delay = 900;
            if(step.type === 'success') delay = 600;
            if(step.type === 'compare') delay = 200;

            setTimeout(process, delay);
        };
        process();
    }

    // --- Drawing ---
    function drawTree(step) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const centerX = canvas.width / 2;
        const data = step ? step.treeSnapshot : root;
        if(!data) return;

        ctx.save();
        ctx.translate(-offsetX, offsetY); 
        ctx.translate(canvas.width/2 + offsetX, 50 + offsetY);
        ctx.scale(scale, scale);
        
        // Center on root X
        ctx.translate(-data.x, 0);

        const drawEdges = (node) => {
            if(!node) return;
            if(node.left) {
                ctx.beginPath(); ctx.moveTo(node.x, node.y); ctx.lineTo(node.left.x, node.left.y);
                ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 2; ctx.stroke();
                drawEdges(node.left);
            }
            if(node.right) {
                ctx.beginPath(); ctx.moveTo(node.x, node.y); ctx.lineTo(node.right.x, node.right.y);
                ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 2; ctx.stroke();
                drawEdges(node.right);
            }
        };
        drawEdges(data);

        const drawNodes = (node) => {
            if(!node) return;
            
            let color = COLORS.normal;
            if(step && step.target && node.x === step.target.x && node.y === step.target.y) {
                 if(step.type === 'compare') color = COLORS.compare;
                 if(step.type === 'success' || step.type === 'spawn') color = COLORS.success;
                 if(step.type === 'imbalance' || step.type === 'rotate') color = COLORS.imbalance;
            }

            ctx.beginPath();
            ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI*2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.8)'; ctx.lineWidth = 2; ctx.stroke();

            // Value
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Inter';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(node.val, node.x, node.y);

            // Balance Factor & Height
            const bf = height(node.left) - height(node.right);
            ctx.fillStyle = (bf > 1 || bf < -1) ? '#ff6b6b' : '#94a3b8';
            ctx.font = '11px Inter';
            ctx.textAlign = 'left';
            // Draw BF to the right
            ctx.fillText(`BF:${bf}`, node.x + 28, node.y - 5);
            ctx.fillStyle = '#94a3b8';
            ctx.fillText(`H:${node.height}`, node.x + 28, node.y + 8);

            drawNodes(node.left);
            drawNodes(node.right);
        };
        drawNodes(data);

        ctx.restore();
    }

    // --- Helpers ---
    function getVal() {
        const el = document.getElementById('valInput');
        if(!el.value) { el.focus(); return null; }
        const v = parseInt(el.value);
        el.value = ''; el.focus();
        return isNaN(v) ? null : v;
    }

    function showStatus(msg) {
        const el = document.getElementById('statusMessage');
        el.innerText = msg; el.classList.add('show');
        setTimeout(()=>el.classList.remove('show'), 2000);
    }
    
    function updateStats() {
        if(!root) {
            document.getElementById('statHeight').innerText = '0';
            document.getElementById('statNodes').innerText = '0';
        } else {
            document.getElementById('statHeight').innerText = height(root);
            document.getElementById('statNodes').innerText = countNodes(root);
        }
        document.getElementById('statRotations').innerText = rotationCount;
    }
    
    function handleRandom() {
        handleClear();
        const vals = Array.from({length: 8}, () => Math.floor(Math.random()*99)+1);
        // Insert manually to trigger balances
        vals.forEach(v => {
            if(!root) root = new AVLNode(v);
            else {
                // We must use the recursive insert to ensure balance!
                const insertRec = (node, val) => {
                    if(!node) return new AVLNode(val);
                    if(val < node.val) node.left = insertRec(node.left, val);
                    else if(val > node.val) node.right = insertRec(node.right, val);
                    else return node;
                    updateHeight(node);
                    let balance = getBalance(node);
                    if(balance > 1 && val < node.left.val) return rightRotate(node);
                    if(balance < -1 && val > node.right.val) return leftRotate(node);
                    if(balance > 1 && val > node.left.val) { node.left = leftRotate(node.left); return rightRotate(node); }
                    if(balance < -1 && val < node.right.val) { node.right = rightRotate(node.right); return leftRotate(node); }
                    return node;
                };
                root = insertRec(root, v);
            }
        });
        updatePositions(root);
        updateStats();
        drawTree(null);
        showStatus("Random Tree Generated");
    }
    
    function handleClear() {
        root = null;
        animationQueue = [];
        rotationCount = 0;
        isAnimating = false;

        // Reset rotation state
        isWaitingForRotation = false;
        pendingRotationType = null;
        skipRootRotation = false;
        rotationCallback = null;
        showRotateButton(false);

        updateStats();
        drawTree(null);
        showStatus("Cleared");
    }
    
    function handleEnter(e) { if(e.key==='Enter') handleInsert(); }
    
    function disableControls(dis) {
        document.querySelectorAll('button:not(.zoom-btn)').forEach(b=>b.disabled=dis);
    }

    // Camera
    function zoomIn() { scale = Math.min(scale*1.2, 2.5); drawTree(null); }
    function zoomOut() { scale = Math.max(scale/1.2, 0.5); drawTree(null); }
    function resetView() { offsetX=0; offsetY=0; scale=1; drawTree(null); }

    // Start
    resizeCanvas();
    updateStats();
    showStatus("Ready");

</script>
</body>
</html>